
usb_test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001100  00004000  00004000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .persistent   00000020  10000000  10000000  00010000  2**0
                  ALLOC
  2 .data         000005a8  10000020  00005100  00008020  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000220  100005c8  000056a8  000085c8  2**2
                  ALLOC
  4 .ARM.attributes 00000029  00000000  00000000  000085c8  2**0
                  CONTENTS, READONLY
  5 .comment      00000070  00000000  00000000  000085f1  2**0
                  CONTENTS, READONLY
  6 .debug_frame  00000a28  00000000  00000000  00008664  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000319e  00000000  00000000  0000908c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001201  00000000  00000000  0000c22a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00001aa9  00000000  00000000  0000d42b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000003a0  00000000  00000000  0000eed4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000003a8  00000000  00000000  0000f274  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000010bf  00000000  00000000  0000f61c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00000ef4  00000000  00000000  000106db  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00004000 <_NVIC_Handler_Functions>:
    4000:	e0 3f 00 10 15 45 00 00 69 45 00 00 69 45 00 00     .?...E..iE..iE..
    4010:	69 45 00 00 69 45 00 00 69 45 00 00 00 00 00 00     iE..iE..iE......
    4020:	00 00 00 00 00 00 00 00 00 00 00 00 69 45 00 00     ............iE..
    4030:	69 45 00 00 00 00 00 00 69 45 00 00 69 45 00 00     iE......iE..iE..
    4040:	69 45 00 00 69 45 00 00 69 45 00 00 69 45 00 00     iE..iE..iE..iE..
    4050:	69 45 00 00 69 45 00 00 69 45 00 00 69 45 00 00     iE..iE..iE..iE..
    4060:	69 45 00 00 69 45 00 00 69 45 00 00 69 45 00 00     iE..iE..iE..iE..
    4070:	69 45 00 00 69 45 00 00 69 45 00 00 69 45 00 00     iE..iE..iE..iE..
    4080:	69 45 00 00 69 45 00 00 69 45 00 00 69 45 00 00     iE..iE..iE..iE..
    4090:	69 45 00 00 69 45 00 00 69 45 00 00 69 45 00 00     iE..iE..iE..iE..
    40a0:	01 44 00 00 69 45 00 00 69 45 00 00 69 45 00 00     .D..iE..iE..iE..
    40b0:	69 45 00 00 69 45 00 00 69 45 00 00 69 45 00 00     iE..iE..iE..iE..
    40c0:	69 45 00 00 69 45 00 00 69 45 00 00                 iE..iE..iE..

000040cc <__do_global_dtors_aux>:
    40cc:	b510      	push	{r4, lr}
    40ce:	4c05      	ldr	r4, [pc, #20]	; (40e4 <__do_global_dtors_aux+0x18>)
    40d0:	7823      	ldrb	r3, [r4, #0]
    40d2:	b933      	cbnz	r3, 40e2 <__do_global_dtors_aux+0x16>
    40d4:	4b04      	ldr	r3, [pc, #16]	; (40e8 <__do_global_dtors_aux+0x1c>)
    40d6:	b113      	cbz	r3, 40de <__do_global_dtors_aux+0x12>
    40d8:	4804      	ldr	r0, [pc, #16]	; (40ec <__do_global_dtors_aux+0x20>)
    40da:	f3af 8000 	nop.w
    40de:	2301      	movs	r3, #1
    40e0:	7023      	strb	r3, [r4, #0]
    40e2:	bd10      	pop	{r4, pc}
    40e4:	100005c8 	.word	0x100005c8
    40e8:	00000000 	.word	0x00000000
    40ec:	000050dc 	.word	0x000050dc

000040f0 <frame_dummy>:
    40f0:	4b08      	ldr	r3, [pc, #32]	; (4114 <frame_dummy+0x24>)
    40f2:	b510      	push	{r4, lr}
    40f4:	b11b      	cbz	r3, 40fe <frame_dummy+0xe>
    40f6:	4808      	ldr	r0, [pc, #32]	; (4118 <frame_dummy+0x28>)
    40f8:	4908      	ldr	r1, [pc, #32]	; (411c <frame_dummy+0x2c>)
    40fa:	f3af 8000 	nop.w
    40fe:	4808      	ldr	r0, [pc, #32]	; (4120 <frame_dummy+0x30>)
    4100:	6803      	ldr	r3, [r0, #0]
    4102:	b903      	cbnz	r3, 4106 <frame_dummy+0x16>
    4104:	bd10      	pop	{r4, pc}
    4106:	4b07      	ldr	r3, [pc, #28]	; (4124 <frame_dummy+0x34>)
    4108:	2b00      	cmp	r3, #0
    410a:	d0fb      	beq.n	4104 <frame_dummy+0x14>
    410c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4110:	4718      	bx	r3
    4112:	bf00      	nop
    4114:	00000000 	.word	0x00000000
    4118:	000050dc 	.word	0x000050dc
    411c:	100005cc 	.word	0x100005cc
    4120:	100005c8 	.word	0x100005c8
    4124:	00000000 	.word	0x00000000

00004128 <__libc_init_array>:
    4128:	b570      	push	{r4, r5, r6, lr}
    412a:	4e0f      	ldr	r6, [pc, #60]	; (4168 <__libc_init_array+0x40>)
    412c:	4d0f      	ldr	r5, [pc, #60]	; (416c <__libc_init_array+0x44>)
    412e:	1b76      	subs	r6, r6, r5
    4130:	10b6      	asrs	r6, r6, #2
    4132:	bf18      	it	ne
    4134:	2400      	movne	r4, #0
    4136:	d005      	beq.n	4144 <__libc_init_array+0x1c>
    4138:	3401      	adds	r4, #1
    413a:	f855 3b04 	ldr.w	r3, [r5], #4
    413e:	4798      	blx	r3
    4140:	42a6      	cmp	r6, r4
    4142:	d1f9      	bne.n	4138 <__libc_init_array+0x10>
    4144:	4e0a      	ldr	r6, [pc, #40]	; (4170 <__libc_init_array+0x48>)
    4146:	4d0b      	ldr	r5, [pc, #44]	; (4174 <__libc_init_array+0x4c>)
    4148:	f000 ffc8 	bl	50dc <_init>
    414c:	1b76      	subs	r6, r6, r5
    414e:	10b6      	asrs	r6, r6, #2
    4150:	bf18      	it	ne
    4152:	2400      	movne	r4, #0
    4154:	d006      	beq.n	4164 <__libc_init_array+0x3c>
    4156:	3401      	adds	r4, #1
    4158:	f855 3b04 	ldr.w	r3, [r5], #4
    415c:	4798      	blx	r3
    415e:	42a6      	cmp	r6, r4
    4160:	d1f9      	bne.n	4156 <__libc_init_array+0x2e>
    4162:	bd70      	pop	{r4, r5, r6, pc}
    4164:	bd70      	pop	{r4, r5, r6, pc}
    4166:	bf00      	nop
    4168:	000050e8 	.word	0x000050e8
    416c:	000050e8 	.word	0x000050e8
    4170:	000050f0 	.word	0x000050f0
    4174:	000050e8 	.word	0x000050e8

00004178 <register_fini>:
    4178:	4b02      	ldr	r3, [pc, #8]	; (4184 <register_fini+0xc>)
    417a:	b113      	cbz	r3, 4182 <register_fini+0xa>
    417c:	4802      	ldr	r0, [pc, #8]	; (4188 <register_fini+0x10>)
    417e:	f000 b805 	b.w	418c <atexit>
    4182:	4770      	bx	lr
    4184:	00000000 	.word	0x00000000
    4188:	00004199 	.word	0x00004199

0000418c <atexit>:
    418c:	4601      	mov	r1, r0
    418e:	2000      	movs	r0, #0
    4190:	4602      	mov	r2, r0
    4192:	4603      	mov	r3, r0
    4194:	f000 b816 	b.w	41c4 <__register_exitproc>

00004198 <__libc_fini_array>:
    4198:	b538      	push	{r3, r4, r5, lr}
    419a:	4b08      	ldr	r3, [pc, #32]	; (41bc <__libc_fini_array+0x24>)
    419c:	4d08      	ldr	r5, [pc, #32]	; (41c0 <__libc_fini_array+0x28>)
    419e:	1aed      	subs	r5, r5, r3
    41a0:	10ac      	asrs	r4, r5, #2
    41a2:	bf18      	it	ne
    41a4:	18ed      	addne	r5, r5, r3
    41a6:	d005      	beq.n	41b4 <__libc_fini_array+0x1c>
    41a8:	3c01      	subs	r4, #1
    41aa:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    41ae:	4798      	blx	r3
    41b0:	2c00      	cmp	r4, #0
    41b2:	d1f9      	bne.n	41a8 <__libc_fini_array+0x10>
    41b4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    41b8:	f000 bf9a 	b.w	50f0 <_fini>
    41bc:	000050fc 	.word	0x000050fc
    41c0:	00005100 	.word	0x00005100

000041c4 <__register_exitproc>:
    41c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    41c8:	4c25      	ldr	r4, [pc, #148]	; (4260 <__register_exitproc+0x9c>)
    41ca:	4606      	mov	r6, r0
    41cc:	6825      	ldr	r5, [r4, #0]
    41ce:	4688      	mov	r8, r1
    41d0:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    41d4:	4692      	mov	sl, r2
    41d6:	4699      	mov	r9, r3
    41d8:	b3c4      	cbz	r4, 424c <__register_exitproc+0x88>
    41da:	6860      	ldr	r0, [r4, #4]
    41dc:	281f      	cmp	r0, #31
    41de:	dc17      	bgt.n	4210 <__register_exitproc+0x4c>
    41e0:	1c41      	adds	r1, r0, #1
    41e2:	b176      	cbz	r6, 4202 <__register_exitproc+0x3e>
    41e4:	eb04 0380 	add.w	r3, r4, r0, lsl #2
    41e8:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
    41ec:	f8d4 5188 	ldr.w	r5, [r4, #392]	; 0x188
    41f0:	2201      	movs	r2, #1
    41f2:	4082      	lsls	r2, r0
    41f4:	4315      	orrs	r5, r2
    41f6:	2e02      	cmp	r6, #2
    41f8:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
    41fc:	f8c3 9108 	str.w	r9, [r3, #264]	; 0x108
    4200:	d01e      	beq.n	4240 <__register_exitproc+0x7c>
    4202:	1c83      	adds	r3, r0, #2
    4204:	6061      	str	r1, [r4, #4]
    4206:	2000      	movs	r0, #0
    4208:	f844 8023 	str.w	r8, [r4, r3, lsl #2]
    420c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4210:	4b14      	ldr	r3, [pc, #80]	; (4264 <__register_exitproc+0xa0>)
    4212:	b303      	cbz	r3, 4256 <__register_exitproc+0x92>
    4214:	f44f 70c8 	mov.w	r0, #400	; 0x190
    4218:	f3af 8000 	nop.w
    421c:	4604      	mov	r4, r0
    421e:	b1d0      	cbz	r0, 4256 <__register_exitproc+0x92>
    4220:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    4224:	2700      	movs	r7, #0
    4226:	e884 0088 	stmia.w	r4, {r3, r7}
    422a:	4638      	mov	r0, r7
    422c:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    4230:	2101      	movs	r1, #1
    4232:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    4236:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    423a:	2e00      	cmp	r6, #0
    423c:	d0e1      	beq.n	4202 <__register_exitproc+0x3e>
    423e:	e7d1      	b.n	41e4 <__register_exitproc+0x20>
    4240:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
    4244:	431a      	orrs	r2, r3
    4246:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    424a:	e7da      	b.n	4202 <__register_exitproc+0x3e>
    424c:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    4250:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    4254:	e7c1      	b.n	41da <__register_exitproc+0x16>
    4256:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    425a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    425e:	bf00      	nop
    4260:	000050b0 	.word	0x000050b0
    4264:	00000000 	.word	0x00000000

00004268 <main>:

#include "ubertooth.h"
#include "usb_serial.h"

int main()
{
    4268:	b508      	push	{r3, lr}
	int c;

	ubertooth_init();
    426a:	f000 fb01 	bl	4870 <ubertooth_init>
	usb_serial_init();
    426e:	f000 f8c9 	bl	4404 <usb_serial_init>
	/*
	 * for each character received over USB serial connection, echo the
	 * character back over USB serial and toggle USRLED
	 */
	while (1) {
		c = VCOM_getchar();
    4272:	f000 f8b3 	bl	43dc <VCOM_getchar>
		if (c != EOF) {
    4276:	1c43      	adds	r3, r0, #1
    4278:	d0fb      	beq.n	4272 <main+0xa>
			/* toggle USRLED */
			if (USRLED)
    427a:	4b06      	ldr	r3, [pc, #24]	; (4294 <main+0x2c>)
    427c:	681b      	ldr	r3, [r3, #0]
    427e:	f013 0f02 	tst.w	r3, #2
				USRLED_CLR;
    4282:	bf14      	ite	ne
    4284:	4a04      	ldrne	r2, [pc, #16]	; (4298 <main+0x30>)
			else
				USRLED_SET;
    4286:	4a05      	ldreq	r2, [pc, #20]	; (429c <main+0x34>)
    4288:	2302      	movs	r3, #2
    428a:	6013      	str	r3, [r2, #0]
			VCOM_putchar(c);
    428c:	f000 f898 	bl	43c0 <VCOM_putchar>
    4290:	e7ef      	b.n	4272 <main+0xa>
    4292:	bf00      	nop
    4294:	2009c034 	.word	0x2009c034
    4298:	2009c03c 	.word	0x2009c03c
    429c:	2009c038 	.word	0x2009c038

000042a0 <USBDevIntHandler>:
	
	Resets state machine when a USB reset is received.
 */
static void USBDevIntHandler(U8 bDevStatus)
{
	if ((bDevStatus & DEV_STATUS_RESET) != 0) {
    42a0:	06c3      	lsls	r3, r0, #27
		fBulkInBusy = FALSE;
    42a2:	bf42      	ittt	mi
    42a4:	4b01      	ldrmi	r3, [pc, #4]	; (42ac <USBDevIntHandler+0xc>)
    42a6:	2200      	movmi	r2, #0
    42a8:	601a      	strmi	r2, [r3, #0]
    42aa:	4770      	bx	lr
    42ac:	100005e4 	.word	0x100005e4

000042b0 <SendNextBulkIn.part.0>:
	Sends the next packet in chain of packets to the host
		
	@param [in] bEP
	@param [in] bEPStatus
 */
static void SendNextBulkIn(U8 bEP, BOOL fFirstPacket)
    42b0:	b570      	push	{r4, r5, r6, lr}
    42b2:	4606      	mov	r6, r0
    42b4:	2400      	movs	r4, #0
    42b6:	490b      	ldr	r1, [pc, #44]	; (42e4 <SendNextBulkIn.part.0+0x34>)
		return;
	}
	
	// get up to MAX_PACKET_SIZE bytes from transmit FIFO into intermediate buffer
	for (iLen = 0; iLen < MAX_PACKET_SIZE; iLen++) {
		if (!fifo_get(&txfifo, &abBulkBuf[iLen])) {
    42b8:	f1a1 000c 	sub.w	r0, r1, #12
    42bc:	4421      	add	r1, r4
    42be:	f000 f8fb 	bl	44b8 <fifo_get>
    42c2:	b110      	cbz	r0, 42ca <SendNextBulkIn.part.0+0x1a>
	if (fChainDone) {
		return;
	}
	
	// get up to MAX_PACKET_SIZE bytes from transmit FIFO into intermediate buffer
	for (iLen = 0; iLen < MAX_PACKET_SIZE; iLen++) {
    42c4:	3401      	adds	r4, #1
    42c6:	2c40      	cmp	r4, #64	; 0x40
    42c8:	d1f5      	bne.n	42b6 <SendNextBulkIn.part.0+0x6>
			break;
		}
	}
	
	// send over USB
	USBHwEPWrite(bEP, abBulkBuf, iLen);
    42ca:	4d07      	ldr	r5, [pc, #28]	; (42e8 <SendNextBulkIn.part.0+0x38>)
    42cc:	4630      	mov	r0, r6
    42ce:	f105 0110 	add.w	r1, r5, #16
    42d2:	4622      	mov	r2, r4
    42d4:	f000 fc44 	bl	4b60 <USBHwEPWrite>
	fBulkInBusy = TRUE;
    42d8:	2301      	movs	r3, #1

	// was this a short packet?
	if (iLen < MAX_PACKET_SIZE) {
    42da:	2c40      	cmp	r4, #64	; 0x40
		}
	}
	
	// send over USB
	USBHwEPWrite(bEP, abBulkBuf, iLen);
	fBulkInBusy = TRUE;
    42dc:	602b      	str	r3, [r5, #0]

	// was this a short packet?
	if (iLen < MAX_PACKET_SIZE) {
		fChainDone = TRUE;
    42de:	bf18      	it	ne
    42e0:	652b      	strne	r3, [r5, #80]	; 0x50
    42e2:	bd70      	pop	{r4, r5, r6, pc}
    42e4:	100005f4 	.word	0x100005f4
    42e8:	100005e4 	.word	0x100005e4

000042ec <USBFrameHandler>:
	packet shorter than the maximum packet size or a zero-length packet
	(as required by the windows usbser.sys driver).

 */
static void USBFrameHandler(U16 wFrame)
{
    42ec:	b538      	push	{r3, r4, r5, lr}
	if (!fBulkInBusy && (fifo_avail(&txfifo) != 0)) {
    42ee:	4c08      	ldr	r4, [pc, #32]	; (4310 <USBFrameHandler+0x24>)
    42f0:	6825      	ldr	r5, [r4, #0]
    42f2:	b965      	cbnz	r5, 430e <USBFrameHandler+0x22>
    42f4:	1d20      	adds	r0, r4, #4
    42f6:	f000 f8f7 	bl	44e8 <fifo_avail>
    42fa:	b140      	cbz	r0, 430e <USBFrameHandler+0x22>
static void SendNextBulkIn(U8 bEP, BOOL fFirstPacket)
{
	int iLen;

	// this transfer is done
	fBulkInBusy = FALSE;
    42fc:	6025      	str	r5, [r4, #0]
	
	// first packet?
	if (fFirstPacket) {
		fChainDone = FALSE;
    42fe:	6525      	str	r5, [r4, #80]	; 0x50
	}

	// last packet?
	if (fChainDone) {
    4300:	6d23      	ldr	r3, [r4, #80]	; 0x50
    4302:	b923      	cbnz	r3, 430e <USBFrameHandler+0x22>
{
	if (!fBulkInBusy && (fifo_avail(&txfifo) != 0)) {
		// send first packet
		SendNextBulkIn(BULK_IN_EP, TRUE);
	}
}
    4304:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    4308:	2082      	movs	r0, #130	; 0x82
    430a:	f7ff bfd1 	b.w	42b0 <SendNextBulkIn.part.0>
    430e:	bd38      	pop	{r3, r4, r5, pc}
    4310:	100005e4 	.word	0x100005e4

00004314 <BulkOut>:
		
	@param [in] bEP
	@param [in] bEPStatus
 */
static void BulkOut(U8 bEP, U8 bEPStatus)
{
    4314:	b570      	push	{r4, r5, r6, lr}
    4316:	4604      	mov	r4, r0
	int i, iLen;

	if (fifo_free(&rxfifo) < MAX_PACKET_SIZE) {
    4318:	480b      	ldr	r0, [pc, #44]	; (4348 <BulkOut+0x34>)
    431a:	f000 f8f5 	bl	4508 <fifo_free>
    431e:	283f      	cmp	r0, #63	; 0x3f
    4320:	dd10      	ble.n	4344 <BulkOut+0x30>
		// may not fit into fifo
		return;
	}

	// get data from USB into intermediate buffer
	iLen = USBHwEPRead(bEP, abBulkBuf, sizeof(abBulkBuf));
    4322:	4620      	mov	r0, r4
    4324:	4909      	ldr	r1, [pc, #36]	; (434c <BulkOut+0x38>)
    4326:	2240      	movs	r2, #64	; 0x40
    4328:	f000 fc4e 	bl	4bc8 <USBHwEPRead>
    432c:	4605      	mov	r5, r0
    432e:	4e07      	ldr	r6, [pc, #28]	; (434c <BulkOut+0x38>)
	for (i = 0; i < iLen; i++) {
    4330:	2400      	movs	r4, #0
    4332:	42ac      	cmp	r4, r5
    4334:	da06      	bge.n	4344 <BulkOut+0x30>
		// put into FIFO
		if (!fifo_put(&rxfifo, abBulkBuf[i])) {
    4336:	4804      	ldr	r0, [pc, #16]	; (4348 <BulkOut+0x34>)
    4338:	5d31      	ldrb	r1, [r6, r4]
    433a:	f000 f8a3 	bl	4484 <fifo_put>
    433e:	b108      	cbz	r0, 4344 <BulkOut+0x30>
		return;
	}

	// get data from USB into intermediate buffer
	iLen = USBHwEPRead(bEP, abBulkBuf, sizeof(abBulkBuf));
	for (i = 0; i < iLen; i++) {
    4340:	3401      	adds	r4, #1
    4342:	e7f6      	b.n	4332 <BulkOut+0x1e>
    4344:	bd70      	pop	{r4, r5, r6, pc}
    4346:	bf00      	nop
    4348:	10000638 	.word	0x10000638
    434c:	100005f4 	.word	0x100005f4

00004350 <HandleClassRequest>:
	@param [in] pSetup
	@param [out] piLen
	@param [out] ppbData
 */
static BOOL HandleClassRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
    4350:	b510      	push	{r4, lr}
	switch (pSetup->bRequest) {
    4352:	7843      	ldrb	r3, [r0, #1]
	@param [in] pSetup
	@param [out] piLen
	@param [out] ppbData
 */
static BOOL HandleClassRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
    4354:	460c      	mov	r4, r1
	switch (pSetup->bRequest) {
    4356:	2b21      	cmp	r3, #33	; 0x21
    4358:	d009      	beq.n	436e <HandleClassRequest+0x1e>
    435a:	2b22      	cmp	r3, #34	; 0x22
    435c:	d00b      	beq.n	4376 <HandleClassRequest+0x26>
    435e:	2b20      	cmp	r3, #32
    4360:	d10b      	bne.n	437a <HandleClassRequest+0x2a>

	// set line coding
	case SET_LINE_CODING:
		memcpy((U8 *)&LineCoding, *ppbData, 7);
    4362:	6811      	ldr	r1, [r2, #0]
    4364:	4806      	ldr	r0, [pc, #24]	; (4380 <HandleClassRequest+0x30>)
    4366:	2207      	movs	r2, #7
    4368:	f000 fe2a 	bl	4fc0 <memcpy>
    436c:	e001      	b.n	4372 <HandleClassRequest+0x22>
		*piLen = 7;
		break;

	// get line coding
	case GET_LINE_CODING:
		*ppbData = (U8 *)&LineCoding;
    436e:	4b04      	ldr	r3, [pc, #16]	; (4380 <HandleClassRequest+0x30>)
    4370:	6013      	str	r3, [r2, #0]
		*piLen = 7;
    4372:	2307      	movs	r3, #7
    4374:	6023      	str	r3, [r4, #0]
		break;

	default:
		return FALSE;
	}
	return TRUE;
    4376:	2001      	movs	r0, #1

	// get line coding
	case GET_LINE_CODING:
		*ppbData = (U8 *)&LineCoding;
		*piLen = 7;
		break;
    4378:	bd10      	pop	{r4, pc}
	// set control line state
	case SET_CONTROL_LINE_STATE:
		break;

	default:
		return FALSE;
    437a:	2000      	movs	r0, #0
	}
	return TRUE;
}
    437c:	bd10      	pop	{r4, pc}
    437e:	bf00      	nop
    4380:	10000448 	.word	0x10000448

00004384 <BulkIn>:
static void SendNextBulkIn(U8 bEP, BOOL fFirstPacket)
{
	int iLen;

	// this transfer is done
	fBulkInBusy = FALSE;
    4384:	4b03      	ldr	r3, [pc, #12]	; (4394 <BulkIn+0x10>)
    4386:	2200      	movs	r2, #0
    4388:	601a      	str	r2, [r3, #0]
	if (fFirstPacket) {
		fChainDone = FALSE;
	}

	// last packet?
	if (fChainDone) {
    438a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    438c:	b90b      	cbnz	r3, 4392 <BulkIn+0xe>
    438e:	f7ff bf8f 	b.w	42b0 <SendNextBulkIn.part.0>
    4392:	4770      	bx	lr
    4394:	100005e4 	.word	0x100005e4

00004398 <VCOM_init>:
/**
	Initialises the VCOM port.
	Call this function before using VCOM_putchar or VCOM_getchar
 */
void VCOM_init(void)
{
    4398:	b510      	push	{r4, lr}
	fifo_init(&txfifo, txdata);
    439a:	4c08      	ldr	r4, [pc, #32]	; (43bc <VCOM_init+0x24>)
    439c:	1d20      	adds	r0, r4, #4
    439e:	f104 0160 	add.w	r1, r4, #96	; 0x60
    43a2:	f000 f869 	bl	4478 <fifo_init>
	fifo_init(&rxfifo, rxdata);
    43a6:	f104 0054 	add.w	r0, r4, #84	; 0x54
    43aa:	f104 01e0 	add.w	r1, r4, #224	; 0xe0
    43ae:	f000 f863 	bl	4478 <fifo_init>
	fBulkInBusy = FALSE;
    43b2:	2300      	movs	r3, #0
    43b4:	6023      	str	r3, [r4, #0]
	fChainDone = TRUE;
    43b6:	2301      	movs	r3, #1
    43b8:	6523      	str	r3, [r4, #80]	; 0x50
    43ba:	bd10      	pop	{r4, pc}
    43bc:	100005e4 	.word	0x100005e4

000043c0 <VCOM_putchar>:
	
	@param [in] c character to write
	@returns character written, or EOF if character could not be written
 */
int VCOM_putchar(int c)
{
    43c0:	b510      	push	{r4, lr}
    43c2:	4604      	mov	r4, r0
	return fifo_put(&txfifo, c) ? c : EOF;
    43c4:	4804      	ldr	r0, [pc, #16]	; (43d8 <VCOM_putchar+0x18>)
    43c6:	b2e1      	uxtb	r1, r4
    43c8:	f000 f85c 	bl	4484 <fifo_put>
    43cc:	2800      	cmp	r0, #0
}
    43ce:	bf14      	ite	ne
    43d0:	4620      	movne	r0, r4
    43d2:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
    43d6:	bd10      	pop	{r4, pc}
    43d8:	100005e8 	.word	0x100005e8

000043dc <VCOM_getchar>:
	Reads one character from VCOM port
	
	@returns character read, or EOF if character could not be read
 */
int VCOM_getchar(void)
{
    43dc:	b507      	push	{r0, r1, r2, lr}
	U8 c;
	
	return fifo_get(&rxfifo, &c) ? c : EOF;
    43de:	4807      	ldr	r0, [pc, #28]	; (43fc <VCOM_getchar+0x20>)
    43e0:	f10d 0107 	add.w	r1, sp, #7
    43e4:	f000 f868 	bl	44b8 <fifo_get>
    43e8:	b110      	cbz	r0, 43f0 <VCOM_getchar+0x14>
    43ea:	f89d 0007 	ldrb.w	r0, [sp, #7]
    43ee:	e001      	b.n	43f4 <VCOM_getchar+0x18>
    43f0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    43f4:	b003      	add	sp, #12
    43f6:	f85d fb04 	ldr.w	pc, [sp], #4
    43fa:	bf00      	nop
    43fc:	10000638 	.word	0x10000638

00004400 <USB_IRQHandler>:

void USB_IRQHandler()
{
	USBHwISR();
    4400:	f000 bc1e 	b.w	4c40 <USBHwISR>

00004404 <usb_serial_init>:
}

void usb_serial_init()
{
    4404:	b508      	push	{r3, lr}
	// initialise stack
	USBInit();
    4406:	f000 fad7 	bl	49b8 <USBInit>

	// register descriptors
	USBRegisterDescriptors(abDescriptors);
    440a:	4813      	ldr	r0, [pc, #76]	; (4458 <usb_serial_init+0x54>)
    440c:	f000 fd0a 	bl	4e24 <USBRegisterDescriptors>

	// register class request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_CLASS, HandleClassRequest, abClassReqData);
    4410:	4a12      	ldr	r2, [pc, #72]	; (445c <usb_serial_init+0x58>)
    4412:	2001      	movs	r0, #1
    4414:	4912      	ldr	r1, [pc, #72]	; (4460 <usb_serial_init+0x5c>)
    4416:	f000 fac5 	bl	49a4 <USBRegisterRequestHandler>

	// register endpoint handlers
	USBHwRegisterEPIntHandler(INT_IN_EP, NULL);
    441a:	2081      	movs	r0, #129	; 0x81
    441c:	2100      	movs	r1, #0
    441e:	f000 fb37 	bl	4a90 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(BULK_IN_EP, BulkIn);
    4422:	2082      	movs	r0, #130	; 0x82
    4424:	490f      	ldr	r1, [pc, #60]	; (4464 <usb_serial_init+0x60>)
    4426:	f000 fb33 	bl	4a90 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(BULK_OUT_EP, BulkOut);
    442a:	490f      	ldr	r1, [pc, #60]	; (4468 <usb_serial_init+0x64>)
    442c:	2005      	movs	r0, #5
    442e:	f000 fb2f 	bl	4a90 <USBHwRegisterEPIntHandler>

	// register frame handler
	USBHwRegisterFrameHandler(USBFrameHandler);
    4432:	480e      	ldr	r0, [pc, #56]	; (446c <usb_serial_init+0x68>)
    4434:	f000 fb52 	bl	4adc <USBHwRegisterFrameHandler>

	// register device event handler
	USBHwRegisterDevIntHandler(USBDevIntHandler);
    4438:	480d      	ldr	r0, [pc, #52]	; (4470 <usb_serial_init+0x6c>)
    443a:	f000 fb43 	bl	4ac4 <USBHwRegisterDevIntHandler>

	// initialise VCOM
	VCOM_init();
    443e:	f7ff ffab 	bl	4398 <VCOM_init>

	// enable USB interrupts
	ISER0 |= ISER0_ISE_USB;
    4442:	4a0c      	ldr	r2, [pc, #48]	; (4474 <usb_serial_init+0x70>)

	// connect to bus
	USBHwConnect(TRUE);
    4444:	2001      	movs	r0, #1

	// initialise VCOM
	VCOM_init();

	// enable USB interrupts
	ISER0 |= ISER0_ISE_USB;
    4446:	6813      	ldr	r3, [r2, #0]
    4448:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    444c:	6013      	str	r3, [r2, #0]

	// connect to bus
	USBHwConnect(TRUE);
}
    444e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	// enable USB interrupts
	ISER0 |= ISER0_ISE_USB;

	// connect to bus
	USBHwConnect(TRUE);
    4452:	f000 bb54 	b.w	4afe <USBHwConnect>
    4456:	bf00      	nop
    4458:	10000450 	.word	0x10000450
    445c:	10000744 	.word	0x10000744
    4460:	00004351 	.word	0x00004351
    4464:	00004385 	.word	0x00004385
    4468:	00004315 	.word	0x00004315
    446c:	000042ed 	.word	0x000042ed
    4470:	000042a1 	.word	0x000042a1
    4474:	e000e100 	.word	0xe000e100

00004478 <fifo_init>:
#include "type.h"
#include "serial_fifo.h"

void fifo_init(fifo_t *fifo, U8 *buf)
{
	fifo->head = 0;
    4478:	2300      	movs	r3, #0
    447a:	6003      	str	r3, [r0, #0]
	fifo->tail = 0;
    447c:	6043      	str	r3, [r0, #4]
	fifo->buf = buf;
    447e:	6081      	str	r1, [r0, #8]
    4480:	4770      	bx	lr
    4482:	0000      	movs	r0, r0

00004484 <fifo_put>:
}


BOOL fifo_put(fifo_t *fifo, U8 c)
{
    4484:	b510      	push	{r4, lr}
	int next;
	
	// check if FIFO has room
	next = (fifo->head + 1) % VCOM_FIFO_SIZE;
    4486:	6802      	ldr	r2, [r0, #0]
    4488:	4b0a      	ldr	r3, [pc, #40]	; (44b4 <fifo_put+0x30>)
    448a:	1c54      	adds	r4, r2, #1
    448c:	4023      	ands	r3, r4
    448e:	2b00      	cmp	r3, #0
    4490:	bfb8      	it	lt
    4492:	f103 33ff 	addlt.w	r3, r3, #4294967295	; 0xffffffff
	if (next == fifo->tail) {
    4496:	6844      	ldr	r4, [r0, #4]
BOOL fifo_put(fifo_t *fifo, U8 c)
{
	int next;
	
	// check if FIFO has room
	next = (fifo->head + 1) % VCOM_FIFO_SIZE;
    4498:	bfbc      	itt	lt
    449a:	f063 037f 	ornlt	r3, r3, #127	; 0x7f
    449e:	3301      	addlt	r3, #1
	if (next == fifo->tail) {
    44a0:	42a3      	cmp	r3, r4
		// full
		return FALSE;
	}
	
	fifo->buf[fifo->head] = c;
    44a2:	bf1f      	itttt	ne
    44a4:	6884      	ldrne	r4, [r0, #8]
    44a6:	54a1      	strbne	r1, [r4, r2]
	fifo->head = next;
    44a8:	6003      	strne	r3, [r0, #0]
	
	return TRUE;
    44aa:	2001      	movne	r0, #1
	
	// check if FIFO has room
	next = (fifo->head + 1) % VCOM_FIFO_SIZE;
	if (next == fifo->tail) {
		// full
		return FALSE;
    44ac:	bf08      	it	eq
    44ae:	2000      	moveq	r0, #0
	
	fifo->buf[fifo->head] = c;
	fifo->head = next;
	
	return TRUE;
}
    44b0:	bd10      	pop	{r4, pc}
    44b2:	bf00      	nop
    44b4:	8000007f 	.word	0x8000007f

000044b8 <fifo_get>:
BOOL fifo_get(fifo_t *fifo, U8 *pc)
{
	int next;
	
	// check if FIFO has data
	if (fifo->head == fifo->tail) {
    44b8:	e890 000c 	ldmia.w	r0, {r2, r3}
    44bc:	429a      	cmp	r2, r3
    44be:	d00f      	beq.n	44e0 <fifo_get+0x28>
		return FALSE;
	}
	
	next = (fifo->tail + 1) % VCOM_FIFO_SIZE;
	
	*pc = fifo->buf[fifo->tail];
    44c0:	6882      	ldr	r2, [r0, #8]
    44c2:	5cd2      	ldrb	r2, [r2, r3]
    44c4:	700a      	strb	r2, [r1, #0]
	// check if FIFO has data
	if (fifo->head == fifo->tail) {
		return FALSE;
	}
	
	next = (fifo->tail + 1) % VCOM_FIFO_SIZE;
    44c6:	1c5a      	adds	r2, r3, #1
    44c8:	4b06      	ldr	r3, [pc, #24]	; (44e4 <fifo_get+0x2c>)
    44ca:	4013      	ands	r3, r2
    44cc:	2b00      	cmp	r3, #0
    44ce:	bfbe      	ittt	lt
    44d0:	f103 33ff 	addlt.w	r3, r3, #4294967295	; 0xffffffff
    44d4:	f063 037f 	ornlt	r3, r3, #127	; 0x7f
    44d8:	3301      	addlt	r3, #1
	
	*pc = fifo->buf[fifo->tail];
	fifo->tail = next;
    44da:	6043      	str	r3, [r0, #4]

	return TRUE;
    44dc:	2001      	movs	r0, #1
    44de:	4770      	bx	lr
{
	int next;
	
	// check if FIFO has data
	if (fifo->head == fifo->tail) {
		return FALSE;
    44e0:	2000      	movs	r0, #0
	
	*pc = fifo->buf[fifo->tail];
	fifo->tail = next;

	return TRUE;
}
    44e2:	4770      	bx	lr
    44e4:	8000007f 	.word	0x8000007f

000044e8 <fifo_avail>:


int fifo_avail(fifo_t *fifo)
{
	return (VCOM_FIFO_SIZE + fifo->head - fifo->tail) % VCOM_FIFO_SIZE;
    44e8:	6803      	ldr	r3, [r0, #0]
    44ea:	6842      	ldr	r2, [r0, #4]
    44ec:	3380      	adds	r3, #128	; 0x80
    44ee:	4805      	ldr	r0, [pc, #20]	; (4504 <fifo_avail+0x1c>)
    44f0:	1a9b      	subs	r3, r3, r2
    44f2:	4018      	ands	r0, r3
    44f4:	2800      	cmp	r0, #0
    44f6:	bfbe      	ittt	lt
    44f8:	f100 30ff 	addlt.w	r0, r0, #4294967295	; 0xffffffff
    44fc:	f060 007f 	ornlt	r0, r0, #127	; 0x7f
    4500:	3001      	addlt	r0, #1
}
    4502:	4770      	bx	lr
    4504:	8000007f 	.word	0x8000007f

00004508 <fifo_free>:


int fifo_free(fifo_t *fifo)
{
    4508:	b508      	push	{r3, lr}
	return (VCOM_FIFO_SIZE - 1 - fifo_avail(fifo));
    450a:	f7ff ffed 	bl	44e8 <fifo_avail>
}
    450e:	f1c0 007f 	rsb	r0, r0, #127	; 0x7f
    4512:	bd08      	pop	{r3, pc}

00004514 <Reset_Handler>:
extern void __libc_init_array(void);
extern int main(void);

/* Reset Handler */
void Reset_Handler(void)
{
    4514:	b508      	push	{r3, lr}
    4516:	4a0d      	ldr	r2, [pc, #52]	; (454c <Reset_Handler+0x38>)
    4518:	4b0d      	ldr	r3, [pc, #52]	; (4550 <Reset_Handler+0x3c>)
	unsigned long *src, *dest;

	// Copy the data segment initializers from flash to SRAM
	src = &_etext;
	for(dest = &_data; dest < &_edata; )
    451a:	490e      	ldr	r1, [pc, #56]	; (4554 <Reset_Handler+0x40>)
    451c:	428b      	cmp	r3, r1
    451e:	d204      	bcs.n	452a <Reset_Handler+0x16>
	{
		*dest++ = *src++;
    4520:	f852 1f04 	ldr.w	r1, [r2, #4]!
    4524:	f843 1b04 	str.w	r1, [r3], #4
    4528:	e7f7      	b.n	451a <Reset_Handler+0x6>
    452a:	4b0b      	ldr	r3, [pc, #44]	; (4558 <Reset_Handler+0x44>)
	}

	// Initialize the .bss segment of memory to zeros
	src = &_bss;
	while (src < &_ebss)
    452c:	4a0b      	ldr	r2, [pc, #44]	; (455c <Reset_Handler+0x48>)
    452e:	4293      	cmp	r3, r2
    4530:	d203      	bcs.n	453a <Reset_Handler+0x26>
	{
		*src++ = 0;
    4532:	2200      	movs	r2, #0
    4534:	f843 2b04 	str.w	r2, [r3], #4
    4538:	e7f8      	b.n	452c <Reset_Handler+0x18>
	}

	__libc_init_array();
    453a:	f7ff fdf5 	bl	4128 <__libc_init_array>

	// Set the vector table location.
	SCB_VTOR = (uint32_t)&_interrupt_vector_table;
    453e:	4b08      	ldr	r3, [pc, #32]	; (4560 <Reset_Handler+0x4c>)
    4540:	4a08      	ldr	r2, [pc, #32]	; (4564 <Reset_Handler+0x50>)
    4542:	601a      	str	r2, [r3, #0]

	main();
    4544:	f7ff fe90 	bl	4268 <main>

	// In case main() fails, have something to breakpoint
	while (1) {;}
    4548:	e7fe      	b.n	4548 <Reset_Handler+0x34>
    454a:	bf00      	nop
    454c:	000050fc 	.word	0x000050fc
    4550:	10000020 	.word	0x10000020
    4554:	100005c8 	.word	0x100005c8
    4558:	100005c8 	.word	0x100005c8
    455c:	100007e8 	.word	0x100007e8
    4560:	e000ed08 	.word	0xe000ed08
    4564:	00004000 	.word	0x00004000

00004568 <ADC_IRQHandler>:
extern unsigned long _StackTop;

extern void Reset_Handler(void);

/* Default interrupt handler */
static void Default_Handler(void) { while(1) {;} }
    4568:	e7fe      	b.n	4568 <ADC_IRQHandler>
    456a:	0000      	movs	r0, r0

0000456c <wait_us>:
	/* This is binary multiply by ~0.3999, i.e, multiply by
	   0.011011011b. The loop also contains 6 instructions at -Os, so
	   why this factor works is not at all related to the comment
	   above ;-) */
	wait_us_counter =
		(us>>2) + (us>>3) + (us>>6) + (us>>7) + (us>>10) + (us>>11);
    456c:	0883      	lsrs	r3, r0, #2
    456e:	eb03 03d0 	add.w	r3, r3, r0, lsr #3
    4572:	eb03 1390 	add.w	r3, r3, r0, lsr #6
    4576:	eb03 13d0 	add.w	r3, r3, r0, lsr #7
    457a:	eb03 2390 	add.w	r3, r3, r0, lsr #10
    457e:	eb03 20d0 	add.w	r0, r3, r0, lsr #11
{
	/* This is binary multiply by ~0.3999, i.e, multiply by
	   0.011011011b. The loop also contains 6 instructions at -Os, so
	   why this factor works is not at all related to the comment
	   above ;-) */
	wait_us_counter =
    4582:	4b04      	ldr	r3, [pc, #16]	; (4594 <wait_us+0x28>)
    4584:	6058      	str	r0, [r3, #4]
		(us>>2) + (us>>3) + (us>>6) + (us>>7) + (us>>10) + (us>>11);
	while(--wait_us_counter);
    4586:	685a      	ldr	r2, [r3, #4]
    4588:	3a01      	subs	r2, #1
    458a:	605a      	str	r2, [r3, #4]
    458c:	2a00      	cmp	r2, #0
    458e:	d1fa      	bne.n	4586 <wait_us+0x1a>
}
    4590:	4770      	bx	lr
    4592:	bf00      	nop
    4594:	1000074c 	.word	0x1000074c

00004598 <all_pins_off>:
}

void all_pins_off(void)
{
	/* configure all pins for GPIO */
	PINSEL0 = 0;
    4598:	4a10      	ldr	r2, [pc, #64]	; (45dc <all_pins_off+0x44>)
    459a:	2300      	movs	r3, #0
    459c:	6013      	str	r3, [r2, #0]
	PINSEL1 = 0;
    459e:	6053      	str	r3, [r2, #4]
	PINSEL2 = 0;
    45a0:	6093      	str	r3, [r2, #8]
	PINSEL3 = 0;
    45a2:	60d3      	str	r3, [r2, #12]
	PINSEL4 = 0;
    45a4:	6113      	str	r3, [r2, #16]
	PINSEL7 = 0;
    45a6:	61d3      	str	r3, [r2, #28]
	PINSEL9 = 0;
    45a8:	6253      	str	r3, [r2, #36]	; 0x24
	PINSEL10 = 0;
    45aa:	6293      	str	r3, [r2, #40]	; 0x28

	/* configure all pins as inputs */
	FIO0DIR = 0;
    45ac:	4a0c      	ldr	r2, [pc, #48]	; (45e0 <all_pins_off+0x48>)
    45ae:	6013      	str	r3, [r2, #0]
	FIO1DIR = 0;
    45b0:	6213      	str	r3, [r2, #32]
	FIO2DIR = 0;
    45b2:	6413      	str	r3, [r2, #64]	; 0x40
	FIO3DIR = 0;
    45b4:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4DIR = 0;
    45b6:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

	/* pull-up on every pin */
	PINMODE0 = 0;
    45ba:	4a0a      	ldr	r2, [pc, #40]	; (45e4 <all_pins_off+0x4c>)
    45bc:	6013      	str	r3, [r2, #0]
	PINMODE1 = 0;
    45be:	6053      	str	r3, [r2, #4]
	PINMODE2 = 0;
    45c0:	6093      	str	r3, [r2, #8]
	PINMODE3 = 0;
    45c2:	60d3      	str	r3, [r2, #12]
	PINMODE4 = 0;
    45c4:	6113      	str	r3, [r2, #16]
	PINMODE7 = 0;
    45c6:	61d3      	str	r3, [r2, #28]
	PINMODE9 = 0;
    45c8:	6253      	str	r3, [r2, #36]	; 0x24

	/* set all outputs low */
	FIO0PIN = 0;
    45ca:	4a07      	ldr	r2, [pc, #28]	; (45e8 <all_pins_off+0x50>)
    45cc:	6013      	str	r3, [r2, #0]
	FIO1PIN = 0;
    45ce:	6213      	str	r3, [r2, #32]
	FIO2PIN = 0;
    45d0:	6413      	str	r3, [r2, #64]	; 0x40
	FIO3PIN = 0;
    45d2:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4PIN = 0;
    45d4:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    45d8:	4770      	bx	lr
    45da:	bf00      	nop
    45dc:	4002c000 	.word	0x4002c000
    45e0:	2009c000 	.word	0x2009c000
    45e4:	4002c040 	.word	0x4002c040
    45e8:	2009c014 	.word	0x2009c014

000045ec <gpio_init>:
/*
 * This should be called very early by every firmware in order to ensure safe
 * operating conditions for the CC2400.
 */
void gpio_init()
{
    45ec:	b508      	push	{r3, lr}
	/* 
	 * Set all pins for GPIO.  This shouldn't be necessary after a reset, but
	 * we might get called at other times.
	 */
	all_pins_off();
    45ee:	f7ff ffd3 	bl	4598 <all_pins_off>
	FIO3DIR = 0;
	FIO4DIR = (PIN_RXLED | PIN_TXLED);
#endif
#ifdef UBERTOOTH_ONE
	FIO0DIR = 0;
	FIO1DIR = (PIN_USRLED | PIN_RXLED | PIN_TXLED | PIN_CC3V3 |
    45f2:	f24c 7112 	movw	r1, #50962	; 0xc712
	FIO2DIR = PIN_SSEL0;
	FIO3DIR = 0;
	FIO4DIR = (PIN_RXLED | PIN_TXLED);
#endif
#ifdef UBERTOOTH_ONE
	FIO0DIR = 0;
    45f6:	4a09      	ldr	r2, [pc, #36]	; (461c <gpio_init+0x30>)
    45f8:	2300      	movs	r3, #0
    45fa:	6013      	str	r3, [r2, #0]
	FIO1DIR = (PIN_USRLED | PIN_RXLED | PIN_TXLED | PIN_CC3V3 |
    45fc:	6211      	str	r1, [r2, #32]
			PIN_RX | PIN_CC1V8 | PIN_BTGR);
	FIO2DIR = (PIN_CSN | PIN_SCLK | PIN_MOSI | PIN_PAEN | PIN_HGM);
    45fe:	f240 11b1 	movw	r1, #433	; 0x1b1
    4602:	6411      	str	r1, [r2, #64]	; 0x40
	FIO3DIR = 0;
	FIO4DIR = (PIN_TX | PIN_SSEL1);
    4604:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
#ifdef UBERTOOTH_ONE
	FIO0DIR = 0;
	FIO1DIR = (PIN_USRLED | PIN_RXLED | PIN_TXLED | PIN_CC3V3 |
			PIN_RX | PIN_CC1V8 | PIN_BTGR);
	FIO2DIR = (PIN_CSN | PIN_SCLK | PIN_MOSI | PIN_PAEN | PIN_HGM);
	FIO3DIR = 0;
    4608:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4DIR = (PIN_TX | PIN_SSEL1);
    460a:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80
	FIO3DIR = 0;
	FIO4DIR = 0;
#endif

	/* set all outputs low */
	FIO0PIN = 0;
    460e:	6153      	str	r3, [r2, #20]
	FIO1PIN = 0;
    4610:	6353      	str	r3, [r2, #52]	; 0x34
	FIO2PIN = 0;
    4612:	6553      	str	r3, [r2, #84]	; 0x54
	FIO3PIN = 0;
    4614:	6753      	str	r3, [r2, #116]	; 0x74
	FIO4PIN = 0;
    4616:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    461a:	bd08      	pop	{r3, pc}
    461c:	2009c000 	.word	0x2009c000

00004620 <atest_init>:
	 * ADC can optionally be configured for ATEST1 and ATEST2, but for now we
	 * set them as floating inputs.
	 */

	/* P0.25 is ATEST1, P0.26 is ATEST2 */
	PINSEL1 &= ~((0x3 << 20) | (0x3 << 18)); // set as GPIO
    4620:	4a09      	ldr	r2, [pc, #36]	; (4648 <atest_init+0x28>)
    4622:	6813      	ldr	r3, [r2, #0]
    4624:	f423 1370 	bic.w	r3, r3, #3932160	; 0x3c0000
    4628:	6013      	str	r3, [r2, #0]
	FIO0DIR &= ~(0x3 << 25); // set as input
    462a:	4a08      	ldr	r2, [pc, #32]	; (464c <atest_init+0x2c>)
    462c:	6813      	ldr	r3, [r2, #0]
    462e:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
    4632:	6013      	str	r3, [r2, #0]
	PINMODE1 |= (0x5 << 19); // no pull-up/pull-down
    4634:	4b06      	ldr	r3, [pc, #24]	; (4650 <atest_init+0x30>)
    4636:	681a      	ldr	r2, [r3, #0]
    4638:	f442 1220 	orr.w	r2, r2, #2621440	; 0x280000
    463c:	601a      	str	r2, [r3, #0]
	PINMODE1 &= ~(0x5 << 18); // no pull-up/pull-down
    463e:	681a      	ldr	r2, [r3, #0]
    4640:	f422 12a0 	bic.w	r2, r2, #1310720	; 0x140000
    4644:	601a      	str	r2, [r3, #0]
    4646:	4770      	bx	lr
    4648:	4002c004 	.word	0x4002c004
    464c:	2009c000 	.word	0x2009c000
    4650:	4002c044 	.word	0x4002c044

00004654 <cc2400_spi>:
 * 2. We're saving the second SPI peripheral for an expansion port.
 * 3. The CC2400 needs CSN held low for the entire transaction which the
 *    LPC17xx SPI peripheral won't do without some workaround anyway.
 */
u32 cc2400_spi(u8 len, u32 data)
{
    4654:	b530      	push	{r4, r5, lr}
	u32 msb = 1 << (len - 1);
    4656:	2501      	movs	r5, #1
    4658:	1e43      	subs	r3, r0, #1
    465a:	409d      	lsls	r5, r3

	/* start transaction by dropping CSN */
	CSN_CLR;
    465c:	4b0d      	ldr	r3, [pc, #52]	; (4694 <cc2400_spi+0x40>)
    465e:	2220      	movs	r2, #32

	while (len--) {
    4660:	3801      	subs	r0, #1
    4662:	b2c0      	uxtb	r0, r0
    4664:	28ff      	cmp	r0, #255	; 0xff

		SCLK_SET;
		if (MISO)
			data |= 1;

		SCLK_CLR;
    4666:	601a      	str	r2, [r3, #0]
    4668:	4c0b      	ldr	r4, [pc, #44]	; (4698 <cc2400_spi+0x44>)
	u32 msb = 1 << (len - 1);

	/* start transaction by dropping CSN */
	CSN_CLR;

	while (len--) {
    466a:	d00f      	beq.n	468c <cc2400_spi+0x38>
		if (data & msb)
    466c:	4229      	tst	r1, r5
    466e:	f04f 0201 	mov.w	r2, #1
			MOSI_SET;
    4672:	bf14      	ite	ne
    4674:	6022      	strne	r2, [r4, #0]
		else
			MOSI_CLR;
    4676:	601a      	streq	r2, [r3, #0]
		data <<= 1;

		SCLK_SET;
    4678:	2210      	movs	r2, #16
    467a:	6022      	str	r2, [r4, #0]
		if (MISO)
    467c:	4c07      	ldr	r4, [pc, #28]	; (469c <cc2400_spi+0x48>)
	while (len--) {
		if (data & msb)
			MOSI_SET;
		else
			MOSI_CLR;
		data <<= 1;
    467e:	0049      	lsls	r1, r1, #1

		SCLK_SET;
		if (MISO)
    4680:	6824      	ldr	r4, [r4, #0]
    4682:	07a4      	lsls	r4, r4, #30
			data |= 1;
    4684:	bf48      	it	mi
    4686:	f041 0101 	orrmi.w	r1, r1, #1
    468a:	e7e9      	b.n	4660 <cc2400_spi+0xc>

		SCLK_CLR;
	}

	/* end transaction by raising CSN */
	CSN_SET;
    468c:	2320      	movs	r3, #32
    468e:	6023      	str	r3, [r4, #0]

	return data;
}
    4690:	4608      	mov	r0, r1
    4692:	bd30      	pop	{r4, r5, pc}
    4694:	2009c05c 	.word	0x2009c05c
    4698:	2009c058 	.word	0x2009c058
    469c:	2009c054 	.word	0x2009c054

000046a0 <cc2400_init>:
	PINMODE1 |= (0x5 << 19); // no pull-up/pull-down
	PINMODE1 &= ~(0x5 << 18); // no pull-up/pull-down
}

void cc2400_init()
{
    46a0:	b510      	push	{r4, lr}
#else
	atest_init();
#endif

	/* activate 1V8 supply for CC2400 */
	CC1V8_SET;
    46a2:	4c0a      	ldr	r4, [pc, #40]	; (46cc <cc2400_init+0x2c>)
	FIO1PIN = 0; /* assuming we have already asserted R8C_CTL low */
	FIO2PIN = 0;
	FIO3PIN = 0;
	FIO4PIN = 0;
#else
	atest_init();
    46a4:	f7ff ffbc 	bl	4620 <atest_init>
#endif

	/* activate 1V8 supply for CC2400 */
	CC1V8_SET;
    46a8:	f44f 7300 	mov.w	r3, #512	; 0x200
    46ac:	6023      	str	r3, [r4, #0]
	wait_us(50);
    46ae:	2032      	movs	r0, #50	; 0x32
    46b0:	f7ff ff5c 	bl	456c <wait_us>

	/* CSN (slave select) is active low */
	CSN_SET;
    46b4:	4b06      	ldr	r3, [pc, #24]	; (46d0 <cc2400_init+0x30>)
    46b6:	2220      	movs	r2, #32
    46b8:	601a      	str	r2, [r3, #0]

	/* activate 3V3 supply for CC2400 IO */
	CC3V3_SET;
    46ba:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    46be:	6023      	str	r3, [r4, #0]

/* write 16 bit value to a register */
void cc2400_set(u8 reg, u16 val)
{
	u32 out = (reg << 16) | val;
	cc2400_spi(24, out);
    46c0:	2018      	movs	r0, #24
    46c2:	4904      	ldr	r1, [pc, #16]	; (46d4 <cc2400_init+0x34>)
	/* activate 3V3 supply for CC2400 IO */
	CC3V3_SET;

	/* initialise various cc2400 settings - see datasheet pg63 */
	cc2400_set(MANAND,  0x7fff);
}
    46c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

/* write 16 bit value to a register */
void cc2400_set(u8 reg, u16 val)
{
	u32 out = (reg << 16) | val;
	cc2400_spi(24, out);
    46c8:	f7ff bfc4 	b.w	4654 <cc2400_spi>
    46cc:	2009c038 	.word	0x2009c038
    46d0:	2009c058 	.word	0x2009c058
    46d4:	000d7fff 	.word	0x000d7fff

000046d8 <cc2400_get>:
	return data;
}

/* read 16 bit value from a register */
u16 cc2400_get(u8 reg)
{
    46d8:	b508      	push	{r3, lr}
	u32 in;

	u32 out = (reg | 0x80) << 16;
    46da:	f040 0180 	orr.w	r1, r0, #128	; 0x80
	in = cc2400_spi(24, out);
    46de:	0409      	lsls	r1, r1, #16
    46e0:	2018      	movs	r0, #24
    46e2:	f7ff ffb7 	bl	4654 <cc2400_spi>
	return in & 0xFFFF;
}
    46e6:	b280      	uxth	r0, r0
    46e8:	bd08      	pop	{r3, pc}

000046ea <cc2400_status>:
	CSN_SET;
}

/* get the status */
u8 cc2400_status()
{
    46ea:	b508      	push	{r3, lr}
	return cc2400_spi(8, 0);
    46ec:	2100      	movs	r1, #0
    46ee:	2008      	movs	r0, #8
    46f0:	f7ff ffb0 	bl	4654 <cc2400_spi>
}
    46f4:	b2c0      	uxtb	r0, r0
    46f6:	bd08      	pop	{r3, pc}

000046f8 <cc2400_strobe>:

/* strobe register, return status */
u8 cc2400_strobe(u8 reg)
{
    46f8:	b508      	push	{r3, lr}
    46fa:	4601      	mov	r1, r0
	return cc2400_spi(8, reg);
    46fc:	2008      	movs	r0, #8
    46fe:	f7ff ffa9 	bl	4654 <cc2400_spi>
}
    4702:	b2c0      	uxtb	r0, r0
    4704:	bd08      	pop	{r3, pc}

00004706 <cc2400_reset>:
/*
 * Warning: This should only be called when running on the internal oscillator.
 * Otherwise use clock_start().
 */
void cc2400_reset()
{
    4706:	b508      	push	{r3, lr}

/* write 16 bit value to a register */
void cc2400_set(u8 reg, u16 val)
{
	u32 out = (reg << 16) | val;
	cc2400_spi(24, out);
    4708:	2018      	movs	r0, #24
    470a:	2100      	movs	r1, #0
    470c:	f7ff ffa2 	bl	4654 <cc2400_spi>
 * Otherwise use clock_start().
 */
void cc2400_reset()
{
	cc2400_set(MAIN, 0x0000);
	while (cc2400_get(MAIN) != 0x0000);
    4710:	2000      	movs	r0, #0
    4712:	f7ff ffe1 	bl	46d8 <cc2400_get>
    4716:	2800      	cmp	r0, #0
    4718:	d1fa      	bne.n	4710 <cc2400_reset+0xa>

/* write 16 bit value to a register */
void cc2400_set(u8 reg, u16 val)
{
	u32 out = (reg << 16) | val;
	cc2400_spi(24, out);
    471a:	2018      	movs	r0, #24
    471c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    4720:	f7ff ff98 	bl	4654 <cc2400_spi>
void cc2400_reset()
{
	cc2400_set(MAIN, 0x0000);
	while (cc2400_get(MAIN) != 0x0000);
	cc2400_set(MAIN, 0x8000);
	while (cc2400_get(MAIN) != 0x8000);
    4724:	2000      	movs	r0, #0
    4726:	f7ff ffd7 	bl	46d8 <cc2400_get>
    472a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    472e:	d1f9      	bne.n	4724 <cc2400_reset+0x1e>
}
    4730:	bd08      	pop	{r3, pc}
    4732:	0000      	movs	r0, r0

00004734 <clock_start>:

/* activate the CC2400's 16 MHz oscillator and sync LPC175x to it */
void clock_start()
{
    4734:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* configure flash accelerator for higher clock rate */
	FLASHCFG = (0x03A | (FLASHTIM << 12));
    4738:	f244 023a 	movw	r2, #16442	; 0x403a
    473c:	4b3e      	ldr	r3, [pc, #248]	; (4838 <clock_start+0x104>)

	/* switch to the internal oscillator if necessary */
	CLKSRCSEL = 0;
    473e:	4f3f      	ldr	r7, [pc, #252]	; (483c <clock_start+0x108>)

/* activate the CC2400's 16 MHz oscillator and sync LPC175x to it */
void clock_start()
{
	/* configure flash accelerator for higher clock rate */
	FLASHCFG = (0x03A | (FLASHTIM << 12));
    4740:	601a      	str	r2, [r3, #0]

	/* switch to the internal oscillator if necessary */
	CLKSRCSEL = 0;

	/* disconnect PLL0 */
	PLL0CON &= ~PLL0CON_PLLC0;
    4742:	4d3f      	ldr	r5, [pc, #252]	; (4840 <clock_start+0x10c>)
{
	/* configure flash accelerator for higher clock rate */
	FLASHCFG = (0x03A | (FLASHTIM << 12));

	/* switch to the internal oscillator if necessary */
	CLKSRCSEL = 0;
    4744:	2300      	movs	r3, #0
    4746:	603b      	str	r3, [r7, #0]

	/* disconnect PLL0 */
	PLL0CON &= ~PLL0CON_PLLC0;
    4748:	682b      	ldr	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
    474a:	4c3e      	ldr	r4, [pc, #248]	; (4844 <clock_start+0x110>)

	/* switch to the internal oscillator if necessary */
	CLKSRCSEL = 0;

	/* disconnect PLL0 */
	PLL0CON &= ~PLL0CON_PLLC0;
    474c:	f023 0302 	bic.w	r3, r3, #2
    4750:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
    4752:	23aa      	movs	r3, #170	; 0xaa
    4754:	6023      	str	r3, [r4, #0]
    4756:	2355      	movs	r3, #85	; 0x55
    4758:	6023      	str	r3, [r4, #0]
	while (PLL0STAT & PLL0STAT_PLLC0_STAT);
    475a:	4e3b      	ldr	r6, [pc, #236]	; (4848 <clock_start+0x114>)
    475c:	6833      	ldr	r3, [r6, #0]
    475e:	0198      	lsls	r0, r3, #6
    4760:	d4fb      	bmi.n	475a <clock_start+0x26>

	/* turn off PLL0 */
	PLL0CON &= ~PLL0CON_PLLE0;
    4762:	682b      	ldr	r3, [r5, #0]
    4764:	f023 0301 	bic.w	r3, r3, #1
    4768:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
    476a:	23aa      	movs	r3, #170	; 0xaa
    476c:	6023      	str	r3, [r4, #0]
    476e:	2355      	movs	r3, #85	; 0x55
    4770:	6023      	str	r3, [r4, #0]
	while (PLL0STAT & PLL0STAT_PLLE0_STAT);
    4772:	6833      	ldr	r3, [r6, #0]
    4774:	f013 7380 	ands.w	r3, r3, #16777216	; 0x1000000
    4778:	d1fb      	bne.n	4772 <clock_start+0x3e>

	/* temporarily set CPU clock divider to 1 */
	CCLKCFG = 0;
    477a:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 486c <clock_start+0x138>
    477e:	f8c8 3000 	str.w	r3, [r8]

	/* configure CC2400 oscillator, output carrier sense on GIO6 */
	cc2400_reset();
    4782:	f7ff ffc0 	bl	4706 <cc2400_reset>

/* write 16 bit value to a register */
void cc2400_set(u8 reg, u16 val)
{
	u32 out = (reg << 16) | val;
	cc2400_spi(24, out);
    4786:	2018      	movs	r0, #24
    4788:	4930      	ldr	r1, [pc, #192]	; (484c <clock_start+0x118>)
    478a:	f7ff ff63 	bl	4654 <cc2400_spi>
	CCLKCFG = 0;

	/* configure CC2400 oscillator, output carrier sense on GIO6 */
	cc2400_reset();
	cc2400_set(IOCFG, (GIO_CARRIER_SENSE_N << 9) | (GIO_CLK_16M << 3));
	cc2400_strobe(SXOSCON);
    478e:	2060      	movs	r0, #96	; 0x60
    4790:	f7ff ffb2 	bl	46f8 <cc2400_strobe>
	while (!(cc2400_status() & XOSC16M_STABLE));
    4794:	f7ff ffa9 	bl	46ea <cc2400_status>
    4798:	0641      	lsls	r1, r0, #25
    479a:	d5fb      	bpl.n	4794 <clock_start+0x60>

	/* activate main oscillator */
	SCS = SCS_OSCEN;
    479c:	4b2c      	ldr	r3, [pc, #176]	; (4850 <clock_start+0x11c>)
    479e:	2220      	movs	r2, #32
    47a0:	601a      	str	r2, [r3, #0]
	while (!(SCS & SCS_OSCSTAT));
    47a2:	681a      	ldr	r2, [r3, #0]
    47a4:	0652      	lsls	r2, r2, #25
    47a6:	d5fc      	bpl.n	47a2 <clock_start+0x6e>
	 * connecting PLL0
 	 */
#ifdef TC13BADGE
	PCLKSEL0  = (1 << 2); /* TIMER0 at cclk (30 MHz) */
#else
	PCLKSEL0  = (2 << 2); /* TIMER0 at cclk/2 (50 MHz) */
    47a8:	4b2a      	ldr	r3, [pc, #168]	; (4854 <clock_start+0x120>)
    47aa:	2208      	movs	r2, #8
    47ac:	601a      	str	r2, [r3, #0]
#endif
	PCLKSEL1  = 0;
    47ae:	2200      	movs	r2, #0
    47b0:	605a      	str	r2, [r3, #4]

	/* switch to main oscillator */
	CLKSRCSEL = 1;
    47b2:	2301      	movs	r3, #1
    47b4:	603b      	str	r3, [r7, #0]

	/* configure PLL0 */
	PLL0CFG = (MSEL0 << 0) | (NSEL0 << 16);
    47b6:	4a28      	ldr	r2, [pc, #160]	; (4858 <clock_start+0x124>)
    47b8:	4b28      	ldr	r3, [pc, #160]	; (485c <clock_start+0x128>)
	PLL0FEED_SEQUENCE;
    47ba:	21aa      	movs	r1, #170	; 0xaa

	/* switch to main oscillator */
	CLKSRCSEL = 1;

	/* configure PLL0 */
	PLL0CFG = (MSEL0 << 0) | (NSEL0 << 16);
    47bc:	601a      	str	r2, [r3, #0]
	PLL0FEED_SEQUENCE;
    47be:	2255      	movs	r2, #85	; 0x55
    47c0:	6021      	str	r1, [r4, #0]
    47c2:	6022      	str	r2, [r4, #0]

	/* turn on PLL0 */
	PLL0CON |= PLL0CON_PLLE0;
    47c4:	682b      	ldr	r3, [r5, #0]
    47c6:	f043 0301 	orr.w	r3, r3, #1
    47ca:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
    47cc:	6021      	str	r1, [r4, #0]
    47ce:	6022      	str	r2, [r4, #0]
	while (!(PLL0STAT & PLL0STAT_PLLE0_STAT));
    47d0:	6833      	ldr	r3, [r6, #0]
    47d2:	01df      	lsls	r7, r3, #7
    47d4:	d5fc      	bpl.n	47d0 <clock_start+0x9c>

	/* set CPU clock divider */
	CCLKCFG = CCLKSEL;
    47d6:	2303      	movs	r3, #3
    47d8:	f8c8 3000 	str.w	r3, [r8]

	/* connect PLL0 */
	PLL0CON |= PLL0CON_PLLC0;
    47dc:	682b      	ldr	r3, [r5, #0]
    47de:	f043 0302 	orr.w	r3, r3, #2
    47e2:	602b      	str	r3, [r5, #0]
	PLL0FEED_SEQUENCE;
    47e4:	23aa      	movs	r3, #170	; 0xaa
    47e6:	6023      	str	r3, [r4, #0]
    47e8:	2355      	movs	r3, #85	; 0x55
    47ea:	6023      	str	r3, [r4, #0]
	while (!(PLL0STAT & PLL0STAT_PLLC0_STAT));
    47ec:	6833      	ldr	r3, [r6, #0]
    47ee:	019d      	lsls	r5, r3, #6
    47f0:	d5fc      	bpl.n	47ec <clock_start+0xb8>

	/* configure PLL1 */
	PLL1CFG = (MSEL1 << 0) | (PSEL1 << 5);
    47f2:	4b1b      	ldr	r3, [pc, #108]	; (4860 <clock_start+0x12c>)
    47f4:	2222      	movs	r2, #34	; 0x22
    47f6:	601a      	str	r2, [r3, #0]
	PLL1FEED_SEQUENCE;
    47f8:	24aa      	movs	r4, #170	; 0xaa
    47fa:	3308      	adds	r3, #8
    47fc:	2055      	movs	r0, #85	; 0x55

	/* turn on PLL1 */
	PLL1CON |= PLL1CON_PLLE1;
    47fe:	4a19      	ldr	r2, [pc, #100]	; (4864 <clock_start+0x130>)
	PLL0FEED_SEQUENCE;
	while (!(PLL0STAT & PLL0STAT_PLLC0_STAT));

	/* configure PLL1 */
	PLL1CFG = (MSEL1 << 0) | (PSEL1 << 5);
	PLL1FEED_SEQUENCE;
    4800:	601c      	str	r4, [r3, #0]
    4802:	6018      	str	r0, [r3, #0]

	/* turn on PLL1 */
	PLL1CON |= PLL1CON_PLLE1;
    4804:	6811      	ldr	r1, [r2, #0]
    4806:	f041 0101 	orr.w	r1, r1, #1
    480a:	6011      	str	r1, [r2, #0]
	PLL1FEED_SEQUENCE;
    480c:	601c      	str	r4, [r3, #0]
    480e:	6018      	str	r0, [r3, #0]
	while (!(PLL1STAT & PLL1STAT_PLLE1_STAT));
    4810:	4915      	ldr	r1, [pc, #84]	; (4868 <clock_start+0x134>)
    4812:	6808      	ldr	r0, [r1, #0]
    4814:	05c4      	lsls	r4, r0, #23
    4816:	d5fb      	bpl.n	4810 <clock_start+0xdc>
	while (!(PLL1STAT & PLL1STAT_PLOCK1));
    4818:	6808      	ldr	r0, [r1, #0]
    481a:	0540      	lsls	r0, r0, #21
    481c:	d5fc      	bpl.n	4818 <clock_start+0xe4>

	/* connect PLL1 */
	PLL1CON |= PLL1CON_PLLC1;
    481e:	6810      	ldr	r0, [r2, #0]
    4820:	f040 0002 	orr.w	r0, r0, #2
    4824:	6010      	str	r0, [r2, #0]
	PLL1FEED_SEQUENCE;
    4826:	22aa      	movs	r2, #170	; 0xaa
    4828:	601a      	str	r2, [r3, #0]
    482a:	2255      	movs	r2, #85	; 0x55
    482c:	601a      	str	r2, [r3, #0]
	while (!(PLL1STAT & PLL1STAT_PLLC1_STAT));
    482e:	680b      	ldr	r3, [r1, #0]
    4830:	059b      	lsls	r3, r3, #22
    4832:	d5fc      	bpl.n	482e <clock_start+0xfa>
}
    4834:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4838:	400fc000 	.word	0x400fc000
    483c:	400fc10c 	.word	0x400fc10c
    4840:	400fc080 	.word	0x400fc080
    4844:	400fc08c 	.word	0x400fc08c
    4848:	400fc088 	.word	0x400fc088
    484c:	00081570 	.word	0x00081570
    4850:	400fc1a0 	.word	0x400fc1a0
    4854:	400fc1a8 	.word	0x400fc1a8
    4858:	00010018 	.word	0x00010018
    485c:	400fc084 	.word	0x400fc084
    4860:	400fc0a4 	.word	0x400fc0a4
    4864:	400fc0a0 	.word	0x400fc0a0
    4868:	400fc0a8 	.word	0x400fc0a8
    486c:	400fc104 	.word	0x400fc104

00004870 <ubertooth_init>:
/*
 * Every application that uses the main oscillator (including any that use both
 * USB and the CC2400) should start with this.
 */
void ubertooth_init()
{
    4870:	b508      	push	{r3, lr}
	gpio_init();
    4872:	f7ff febb 	bl	45ec <gpio_init>
	cc2400_init();
    4876:	f7ff ff13 	bl	46a0 <cc2400_init>
	clock_start();
}
    487a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 */
void ubertooth_init()
{
	gpio_init();
	cc2400_init();
	clock_start();
    487e:	f7ff bf59 	b.w	4734 <clock_start>
    4882:	0000      	movs	r0, r0

00004884 <DataIn>:

/**
	Sends next chunk of data (possibly 0 bytes) to host
 */
static void DataIn(void)
{
    4884:	b538      	push	{r3, r4, r5, lr}
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
    4886:	4c08      	ldr	r4, [pc, #32]	; (48a8 <DataIn+0x24>)
	USBHwEPWrite(0x80, pbData, iChunk);
    4888:	2080      	movs	r0, #128	; 0x80
 */
static void DataIn(void)
{
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
    488a:	6825      	ldr	r5, [r4, #0]
	USBHwEPWrite(0x80, pbData, iChunk);
    488c:	6861      	ldr	r1, [r4, #4]
 */
static void DataIn(void)
{
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
    488e:	2d40      	cmp	r5, #64	; 0x40
    4890:	bfa8      	it	ge
    4892:	2540      	movge	r5, #64	; 0x40
	USBHwEPWrite(0x80, pbData, iChunk);
    4894:	462a      	mov	r2, r5
    4896:	f000 f963 	bl	4b60 <USBHwEPWrite>
	pbData += iChunk;
    489a:	6863      	ldr	r3, [r4, #4]
    489c:	442b      	add	r3, r5
    489e:	6063      	str	r3, [r4, #4]
	iResidue -= iChunk;
    48a0:	6823      	ldr	r3, [r4, #0]
    48a2:	1b5d      	subs	r5, r3, r5
    48a4:	6025      	str	r5, [r4, #0]
    48a6:	bd38      	pop	{r3, r4, r5, pc}
    48a8:	10000754 	.word	0x10000754

000048ac <_HandleRequest.constprop.1>:
	@param [in,out]	*piLen		Pointer to data length
	@param [in,out]	ppbData		Data buffer.

	@return TRUE if the request was handles successfully
 */
static BOOL _HandleRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
    48ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
{
	TFnHandleRequest *pfnHandler;
	int iType;
	
	iType = REQTYPE_GET_TYPE(pSetup->bmRequestType);
    48ae:	4b11      	ldr	r3, [pc, #68]	; (48f4 <_HandleRequest.constprop.1+0x48>)
    48b0:	7a1c      	ldrb	r4, [r3, #8]
    48b2:	461d      	mov	r5, r3
    48b4:	f3c4 1441 	ubfx	r4, r4, #5, #2
	
	if(iType == REQTYPE_TYPE_VENDOR) {
    48b8:	2c02      	cmp	r4, #2
    48ba:	d10d      	bne.n	48d8 <_HandleRequest.constprop.1+0x2c>
		BOOL fFilterStatus = FALSE;
    48bc:	2200      	movs	r2, #0
    48be:	a902      	add	r1, sp, #8
    48c0:	f841 2d04 	str.w	r2, [r1, #-4]!
		if(USBFilterOsVendorMessage(pSetup, &fFilterStatus, piLen, ppbData)) {
    48c4:	f103 0008 	add.w	r0, r3, #8
    48c8:	f103 0210 	add.w	r2, r3, #16
    48cc:	3304      	adds	r3, #4
    48ce:	f000 fa75 	bl	4dbc <USBFilterOsVendorMessage>
    48d2:	b108      	cbz	r0, 48d8 <_HandleRequest.constprop.1+0x2c>
			return fFilterStatus;
    48d4:	9801      	ldr	r0, [sp, #4]
    48d6:	e00a      	b.n	48ee <_HandleRequest.constprop.1+0x42>
		}
	}
	
	pfnHandler = apfnReqHandlers[iType];
    48d8:	eb05 0484 	add.w	r4, r5, r4, lsl #2
    48dc:	6963      	ldr	r3, [r4, #20]
	if (pfnHandler == NULL) {
    48de:	b12b      	cbz	r3, 48ec <_HandleRequest.constprop.1+0x40>
		DBG("No handler for reqtype %d\n", iType);
		return FALSE;
	}

	return pfnHandler(pSetup, piLen, ppbData);
    48e0:	4805      	ldr	r0, [pc, #20]	; (48f8 <_HandleRequest.constprop.1+0x4c>)
    48e2:	f100 0108 	add.w	r1, r0, #8
    48e6:	1f02      	subs	r2, r0, #4
    48e8:	4798      	blx	r3
    48ea:	e000      	b.n	48ee <_HandleRequest.constprop.1+0x42>
	}
	
	pfnHandler = apfnReqHandlers[iType];
	if (pfnHandler == NULL) {
		DBG("No handler for reqtype %d\n", iType);
		return FALSE;
    48ec:	4618      	mov	r0, r3
	}

	return pfnHandler(pSetup, piLen, ppbData);
}
    48ee:	b003      	add	sp, #12
    48f0:	bd30      	pop	{r4, r5, pc}
    48f2:	bf00      	nop
    48f4:	10000754 	.word	0x10000754
    48f8:	1000075c 	.word	0x1000075c

000048fc <USBHandleControlTransfer>:
 *
 *	@param [in]	bEP		Endpoint address
 *	@param [in]	bEPStat	Endpoint status
 */
void USBHandleControlTransfer(U8 bEP, U8 bEPStat)
{
    48fc:	b510      	push	{r4, lr}
	int iChunk, iType;

	if (bEP == 0x00) {
    48fe:	2800      	cmp	r0, #0
    4900:	d14a      	bne.n	4998 <USBHandleControlTransfer+0x9c>
		// OUT transfer
		if (bEPStat & EP_STATUS_SETUP) {
    4902:	f001 0304 	and.w	r3, r1, #4
    4906:	f003 01ff 	and.w	r1, r3, #255	; 0xff
    490a:	4c25      	ldr	r4, [pc, #148]	; (49a0 <USBHandleControlTransfer+0xa4>)
    490c:	b30b      	cbz	r3, 4952 <USBHandleControlTransfer+0x56>
			// setup packet, reset request message state machine
			USBHwEPRead(0x00, (U8 *)&Setup, sizeof(Setup));
    490e:	2208      	movs	r2, #8
    4910:	f104 0108 	add.w	r1, r4, #8
    4914:	f000 f958 	bl	4bc8 <USBHwEPRead>
			DBG("S%x", Setup.bRequest);

			// defaults for data pointer and residue
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
    4918:	7a22      	ldrb	r2, [r4, #8]
    491a:	f3c2 1341 	ubfx	r3, r2, #5, #2
			pbData = apbDataStore[iType];
    491e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    4922:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    4924:	6063      	str	r3, [r4, #4]
			iResidue = Setup.wLength;
    4926:	89e3      	ldrh	r3, [r4, #14]
    4928:	6023      	str	r3, [r4, #0]
			iLen = Setup.wLength;
    492a:	6123      	str	r3, [r4, #16]

			if ((Setup.wLength == 0) ||
    492c:	b10b      	cbz	r3, 4932 <USBHandleControlTransfer+0x36>
    492e:	09d3      	lsrs	r3, r2, #7
    4930:	d034      	beq.n	499c <USBHandleControlTransfer+0xa0>
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
				// ask installed handler to process request
				if (!_HandleRequest(&Setup, &iLen, &pbData)) {
    4932:	f7ff ffbb 	bl	48ac <_HandleRequest.constprop.1>
    4936:	b928      	cbnz	r0, 4944 <USBHandleControlTransfer+0x48>
		DataIn();
	}
	else {
		ASSERT(FALSE);
	}
}
    4938:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static void StallControlPipe(U8 bEPStat)
{
	U8	*pb;
	int	i;

	USBHwEPStall(0x80, TRUE);
    493c:	2080      	movs	r0, #128	; 0x80
    493e:	2101      	movs	r1, #1
    4940:	f000 b902 	b.w	4b48 <USBHwEPStall>
					DBG("_HandleRequest1 failed\n");
					StallControlPipe(bEPStat);
					return;
				}
				// send smallest of requested and offered length
				iResidue = MIN(iLen, Setup.wLength);
    4944:	89e2      	ldrh	r2, [r4, #14]
    4946:	6923      	ldr	r3, [r4, #16]
    4948:	429a      	cmp	r2, r3
    494a:	bfd4      	ite	le
    494c:	6022      	strle	r2, [r4, #0]
    494e:	6023      	strgt	r3, [r4, #0]
    4950:	e019      	b.n	4986 <USBHandleControlTransfer+0x8a>
				// send first part (possibly a zero-length status message)
				DataIn();
			}
		}
		else {		
			if (iResidue > 0) {
    4952:	6822      	ldr	r2, [r4, #0]
    4954:	2a00      	cmp	r2, #0
    4956:	dd1a      	ble.n	498e <USBHandleControlTransfer+0x92>
				// store data
				iChunk = USBHwEPRead(0x00, pbData, iResidue);
    4958:	6861      	ldr	r1, [r4, #4]
    495a:	f000 f935 	bl	4bc8 <USBHwEPRead>
				if (iChunk < 0) {
    495e:	2800      	cmp	r0, #0
    4960:	dbea      	blt.n	4938 <USBHandleControlTransfer+0x3c>
					StallControlPipe(bEPStat);
					return;
				}
				pbData += iChunk;
    4962:	6863      	ldr	r3, [r4, #4]
    4964:	4403      	add	r3, r0
    4966:	6063      	str	r3, [r4, #4]
				iResidue -= iChunk;
    4968:	6823      	ldr	r3, [r4, #0]
    496a:	1a18      	subs	r0, r3, r0
    496c:	6020      	str	r0, [r4, #0]
				if (iResidue == 0) {
    496e:	b9a8      	cbnz	r0, 499c <USBHandleControlTransfer+0xa0>
					// received all, send data to handler
					iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
    4970:	7a23      	ldrb	r3, [r4, #8]
    4972:	f3c3 1341 	ubfx	r3, r3, #5, #2
					pbData = apbDataStore[iType];
    4976:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    497a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    497c:	6063      	str	r3, [r4, #4]
					if (!_HandleRequest(&Setup, &iLen, &pbData)) {
    497e:	f7ff ff95 	bl	48ac <_HandleRequest.constprop.1>
    4982:	2800      	cmp	r0, #0
    4984:	d0d8      	beq.n	4938 <USBHandleControlTransfer+0x3c>
		DataIn();
	}
	else {
		ASSERT(FALSE);
	}
}
    4986:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
						DBG("_HandleRequest2 failed\n");
						StallControlPipe(bEPStat);
						return;
					}
					// send status to host
					DataIn();
    498a:	f7ff bf7b 	b.w	4884 <DataIn>
				}
			}
			else {
				// absorb zero-length status message
				iChunk = USBHwEPRead(0x00, NULL, 0);
    498e:	460a      	mov	r2, r1
		DataIn();
	}
	else {
		ASSERT(FALSE);
	}
}
    4990:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
					DataIn();
				}
			}
			else {
				// absorb zero-length status message
				iChunk = USBHwEPRead(0x00, NULL, 0);
    4994:	f000 b918 	b.w	4bc8 <USBHwEPRead>
				DBG(iChunk > 0 ? "?" : "");
			}
		}
	}
	else if (bEP == 0x80) {
    4998:	2880      	cmp	r0, #128	; 0x80
    499a:	d0f4      	beq.n	4986 <USBHandleControlTransfer+0x8a>
    499c:	bd10      	pop	{r4, pc}
    499e:	bf00      	nop
    49a0:	10000754 	.word	0x10000754

000049a4 <USBRegisterRequestHandler>:
 */
void USBRegisterRequestHandler(int iType, TFnHandleRequest *pfnHandler, U8 *pbDataStore)
{
	ASSERT(iType >= 0);
	ASSERT(iType < 4);
	apfnReqHandlers[iType] = pfnHandler;
    49a4:	4b02      	ldr	r3, [pc, #8]	; (49b0 <USBRegisterRequestHandler+0xc>)
    49a6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    49aa:	6141      	str	r1, [r0, #20]
	apbDataStore[iType] = pbDataStore;
    49ac:	6242      	str	r2, [r0, #36]	; 0x24
    49ae:	4770      	bx	lr
    49b0:	10000754 	.word	0x10000754

000049b4 <HandleUsbReset>:
	USB reset handler
	
	@param [in] bDevStatus	Device status
 */
static void HandleUsbReset(U8 bDevStatus)
{
    49b4:	4770      	bx	lr
    49b6:	0000      	movs	r0, r0

000049b8 <USBInit>:
	installing default callbacks.
	
	@return TRUE if initialisation was successful
 */
BOOL USBInit(void)
{
    49b8:	b510      	push	{r4, lr}
	
	// register bus reset handler
	USBHwRegisterDevIntHandler(HandleUsbReset);
	
	// register control transfer handler on EP0
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
    49ba:	4c0e      	ldr	r4, [pc, #56]	; (49f4 <USBInit+0x3c>)
	@return TRUE if initialisation was successful
 */
BOOL USBInit(void)
{
	// init hardware
	USBHwInit();
    49bc:	f000 f9a6 	bl	4d0c <USBHwInit>
	
	// register bus reset handler
	USBHwRegisterDevIntHandler(HandleUsbReset);
    49c0:	480d      	ldr	r0, [pc, #52]	; (49f8 <USBInit+0x40>)
    49c2:	f000 f87f 	bl	4ac4 <USBHwRegisterDevIntHandler>
	
	// register control transfer handler on EP0
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
    49c6:	4621      	mov	r1, r4
    49c8:	2000      	movs	r0, #0
    49ca:	f000 f861 	bl	4a90 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(0x80, USBHandleControlTransfer);
    49ce:	4621      	mov	r1, r4
    49d0:	2080      	movs	r0, #128	; 0x80
    49d2:	f000 f85d 	bl	4a90 <USBHwRegisterEPIntHandler>
	
	// setup control endpoints
	USBHwEPConfig(0x00, MAX_PACKET_SIZE0);
    49d6:	2000      	movs	r0, #0
    49d8:	2140      	movs	r1, #64	; 0x40
    49da:	f000 f83b 	bl	4a54 <USBHwEPConfig>
	USBHwEPConfig(0x80, MAX_PACKET_SIZE0);
    49de:	2080      	movs	r0, #128	; 0x80
    49e0:	2140      	movs	r1, #64	; 0x40
    49e2:	f000 f837 	bl	4a54 <USBHwEPConfig>
	
	// register standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_STANDARD, USBHandleStandardRequest, abStdReqData);
    49e6:	2000      	movs	r0, #0
    49e8:	4904      	ldr	r1, [pc, #16]	; (49fc <USBInit+0x44>)
    49ea:	4a05      	ldr	r2, [pc, #20]	; (4a00 <USBInit+0x48>)
    49ec:	f7ff ffda 	bl	49a4 <USBRegisterRequestHandler>

	return TRUE;
}
    49f0:	2001      	movs	r0, #1
    49f2:	bd10      	pop	{r4, pc}
    49f4:	000048fd 	.word	0x000048fd
    49f8:	000049b5 	.word	0x000049b5
    49fc:	00004e89 	.word	0x00004e89
    4a00:	10000788 	.word	0x10000788

00004a04 <Wait4DevInt>:
    @param [in] dwIntr      Bitmask of interrupts to wait for   
 */
static void Wait4DevInt(U32 dwIntr)
{
    // wait for specific interrupt
    while ((USBDevIntSt & dwIntr) != dwIntr);
    4a04:	4b03      	ldr	r3, [pc, #12]	; (4a14 <Wait4DevInt+0x10>)
    4a06:	681b      	ldr	r3, [r3, #0]
    4a08:	4003      	ands	r3, r0
    4a0a:	4283      	cmp	r3, r0
    4a0c:	d1fa      	bne.n	4a04 <Wait4DevInt>
    // clear the interrupt bits
    USBDevIntClr = dwIntr;
    4a0e:	4b02      	ldr	r3, [pc, #8]	; (4a18 <Wait4DevInt+0x14>)
    4a10:	6018      	str	r0, [r3, #0]
    4a12:	4770      	bx	lr
    4a14:	5000c200 	.word	0x5000c200
    4a18:	5000c208 	.word	0x5000c208

00004a1c <USBHwCmd>:
    @param [in] bCmd        Command to send
 */
static void USBHwCmd(U8 bCmd)
{
    // clear CDFULL/CCEMTY
    USBDevIntClr = CDFULL | CCEMTY;
    4a1c:	4b04      	ldr	r3, [pc, #16]	; (4a30 <USBHwCmd+0x14>)
    // write command code
    USBCmdCode = 0x00000500 | (bCmd << 16);
    4a1e:	0400      	lsls	r0, r0, #16
    4a20:	f440 60a0 	orr.w	r0, r0, #1280	; 0x500
    @param [in] bCmd        Command to send
 */
static void USBHwCmd(U8 bCmd)
{
    // clear CDFULL/CCEMTY
    USBDevIntClr = CDFULL | CCEMTY;
    4a24:	2230      	movs	r2, #48	; 0x30
    4a26:	601a      	str	r2, [r3, #0]
    // write command code
    USBCmdCode = 0x00000500 | (bCmd << 16);
    4a28:	6098      	str	r0, [r3, #8]
    Wait4DevInt(CCEMTY);
    4a2a:	2010      	movs	r0, #16
    4a2c:	f7ff bfea 	b.w	4a04 <Wait4DevInt>
    4a30:	5000c208 	.word	0x5000c208

00004a34 <USBHwCmdWrite>:
        
    @param [in] bCmd        Command to send
    @param [in] bData       Data to send
 */
static void USBHwCmdWrite(U8 bCmd, U16 bData)
{
    4a34:	b510      	push	{r4, lr}
    4a36:	460c      	mov	r4, r1
    // write command code
    USBHwCmd(bCmd);
    4a38:	f7ff fff0 	bl	4a1c <USBHwCmd>

    // write command data
    USBCmdCode = 0x00000100 | (bData << 16);
    4a3c:	0424      	lsls	r4, r4, #16
    4a3e:	4b04      	ldr	r3, [pc, #16]	; (4a50 <USBHwCmdWrite+0x1c>)
    4a40:	f444 7480 	orr.w	r4, r4, #256	; 0x100
    4a44:	601c      	str	r4, [r3, #0]
    Wait4DevInt(CCEMTY);
    4a46:	2010      	movs	r0, #16
}
    4a48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    // write command code
    USBHwCmd(bCmd);

    // write command data
    USBCmdCode = 0x00000100 | (bData << 16);
    Wait4DevInt(CCEMTY);
    4a4c:	f7ff bfda 	b.w	4a04 <Wait4DevInt>
    4a50:	5000c210 	.word	0x5000c210

00004a54 <USBHwEPConfig>:
        
    @param [in] bEP             Endpoint number
    @param [in] wMaxPacketSize  Maximum packet size for this EP
 */
void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
{
    4a54:	b510      	push	{r4, lr}
    int idx;
    
    idx = EP2IDX(bEP);
    4a56:	f000 040f 	and.w	r4, r0, #15
    4a5a:	09c0      	lsrs	r0, r0, #7
    4a5c:	ea40 0444 	orr.w	r4, r0, r4, lsl #1
    @param [in] idx         Endpoint index
    @param [in] wMaxPSize   Maximum packet size for this endpoint
 */
static void USBHwEPRealize(int idx, U16 wMaxPSize)
{
    USBReEp |= (1 << idx);
    4a60:	4809      	ldr	r0, [pc, #36]	; (4a88 <USBHwEPConfig+0x34>)
    4a62:	2301      	movs	r3, #1
    4a64:	6802      	ldr	r2, [r0, #0]
    4a66:	40a3      	lsls	r3, r4
    4a68:	4313      	orrs	r3, r2
    4a6a:	6003      	str	r3, [r0, #0]
#ifdef LPC17xx
    USBEpIn = idx;
    4a6c:	4b07      	ldr	r3, [pc, #28]	; (4a8c <USBHwEPConfig+0x38>)
#else
    USBEpInd = idx;
#endif
    USBMaxPSize = wMaxPSize;
    Wait4DevInt(EP_RLZED);
    4a6e:	f44f 7080 	mov.w	r0, #256	; 0x100
 */
static void USBHwEPRealize(int idx, U16 wMaxPSize)
{
    USBReEp |= (1 << idx);
#ifdef LPC17xx
    USBEpIn = idx;
    4a72:	601c      	str	r4, [r3, #0]
#else
    USBEpInd = idx;
#endif
    USBMaxPSize = wMaxPSize;
    4a74:	6059      	str	r1, [r3, #4]
    Wait4DevInt(EP_RLZED);
    4a76:	f7ff ffc5 	bl	4a04 <Wait4DevInt>
    @param [in] idx     Endpoint index
    @param [in] fEnable TRUE to enable, FALSE to disable
 */
static void USBHwEPEnable(int idx, BOOL fEnable)
{
    USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
    4a7a:	f044 0040 	orr.w	r0, r4, #64	; 0x40
    4a7e:	2100      	movs	r1, #0
    // realise EP
    USBHwEPRealize(idx, wMaxPacketSize);

    // enable EP
    USBHwEPEnable(idx, TRUE);
}
    4a80:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    @param [in] idx     Endpoint index
    @param [in] fEnable TRUE to enable, FALSE to disable
 */
static void USBHwEPEnable(int idx, BOOL fEnable)
{
    USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
    4a84:	f7ff bfd6 	b.w	4a34 <USBHwCmdWrite>
    4a88:	5000c244 	.word	0x5000c244
    4a8c:	5000c248 	.word	0x5000c248

00004a90 <USBHwRegisterEPIntHandler>:
    idx = EP2IDX(bEP);

    ASSERT(idx<32);

    /* add handler to list of EP handlers */
    _apfnEPIntHandlers[idx / 2] = pfnHandler;
    4a90:	4a09      	ldr	r2, [pc, #36]	; (4ab8 <USBHwRegisterEPIntHandler+0x28>)
 */
void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
{
    int idx;
    
    idx = EP2IDX(bEP);
    4a92:	f000 030f 	and.w	r3, r0, #15

    ASSERT(idx<32);

    /* add handler to list of EP handlers */
    _apfnEPIntHandlers[idx / 2] = pfnHandler;
    4a96:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    
    /* enable EP interrupt */
    USBEpIntEn |= (1 << idx);
    4a9a:	4908      	ldr	r1, [pc, #32]	; (4abc <USBHwRegisterEPIntHandler+0x2c>)
 */
void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
{
    int idx;
    
    idx = EP2IDX(bEP);
    4a9c:	09c0      	lsrs	r0, r0, #7

    /* add handler to list of EP handlers */
    _apfnEPIntHandlers[idx / 2] = pfnHandler;
    
    /* enable EP interrupt */
    USBEpIntEn |= (1 << idx);
    4a9e:	680a      	ldr	r2, [r1, #0]
    idx = EP2IDX(bEP);

    ASSERT(idx<32);

    /* add handler to list of EP handlers */
    _apfnEPIntHandlers[idx / 2] = pfnHandler;
    4aa0:	ea40 0043 	orr.w	r0, r0, r3, lsl #1
    
    /* enable EP interrupt */
    USBEpIntEn |= (1 << idx);
    4aa4:	2301      	movs	r3, #1
    4aa6:	4083      	lsls	r3, r0
    4aa8:	4313      	orrs	r3, r2
    USBDevIntEn |= EP_SLOW;
    4aaa:	4a05      	ldr	r2, [pc, #20]	; (4ac0 <USBHwRegisterEPIntHandler+0x30>)

    /* add handler to list of EP handlers */
    _apfnEPIntHandlers[idx / 2] = pfnHandler;
    
    /* enable EP interrupt */
    USBEpIntEn |= (1 << idx);
    4aac:	600b      	str	r3, [r1, #0]
    USBDevIntEn |= EP_SLOW;
    4aae:	6813      	ldr	r3, [r2, #0]
    4ab0:	f043 0304 	orr.w	r3, r3, #4
    4ab4:	6013      	str	r3, [r2, #0]
    4ab6:	4770      	bx	lr
    4ab8:	10000790 	.word	0x10000790
    4abc:	5000c234 	.word	0x5000c234
    4ac0:	5000c204 	.word	0x5000c204

00004ac4 <USBHwRegisterDevIntHandler>:
        
    @param [in] pfnHandler  Callback function
 */
void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
{
    _pfnDevIntHandler = pfnHandler;
    4ac4:	4b03      	ldr	r3, [pc, #12]	; (4ad4 <USBHwRegisterDevIntHandler+0x10>)
    
    // enable device interrupt
    USBDevIntEn |= DEV_STAT;
    4ac6:	4a04      	ldr	r2, [pc, #16]	; (4ad8 <USBHwRegisterDevIntHandler+0x14>)
        
    @param [in] pfnHandler  Callback function
 */
void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
{
    _pfnDevIntHandler = pfnHandler;
    4ac8:	6418      	str	r0, [r3, #64]	; 0x40
    
    // enable device interrupt
    USBDevIntEn |= DEV_STAT;
    4aca:	6813      	ldr	r3, [r2, #0]
    4acc:	f043 0308 	orr.w	r3, r3, #8
    4ad0:	6013      	str	r3, [r2, #0]
    4ad2:	4770      	bx	lr
    4ad4:	10000790 	.word	0x10000790
    4ad8:	5000c204 	.word	0x5000c204

00004adc <USBHwRegisterFrameHandler>:
        
    @param [in] pfnHandler  Callback function
 */
void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
{
    _pfnFrameHandler = pfnHandler;
    4adc:	4b03      	ldr	r3, [pc, #12]	; (4aec <USBHwRegisterFrameHandler+0x10>)
    
    // enable device interrupt
    USBDevIntEn |= FRAME;
    4ade:	4a04      	ldr	r2, [pc, #16]	; (4af0 <USBHwRegisterFrameHandler+0x14>)
        
    @param [in] pfnHandler  Callback function
 */
void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
{
    _pfnFrameHandler = pfnHandler;
    4ae0:	6458      	str	r0, [r3, #68]	; 0x44
    
    // enable device interrupt
    USBDevIntEn |= FRAME;
    4ae2:	6813      	ldr	r3, [r2, #0]
    4ae4:	f043 0301 	orr.w	r3, r3, #1
    4ae8:	6013      	str	r3, [r2, #0]
    4aea:	4770      	bx	lr
    4aec:	10000790 	.word	0x10000790
    4af0:	5000c204 	.word	0x5000c204

00004af4 <USBHwSetAddress>:
        
    @param [in] bAddr       Device address to set
 */
void USBHwSetAddress(U8 bAddr)
{
    USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
    4af4:	f040 0180 	orr.w	r1, r0, #128	; 0x80
    4af8:	20d0      	movs	r0, #208	; 0xd0
    4afa:	f7ff bf9b 	b.w	4a34 <USBHwCmdWrite>

00004afe <USBHwConnect>:
    FIO0CLR = (1<<14);
  else
    FIO0SET = (1<<14);
#endif
#endif
    USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
    4afe:	1c01      	adds	r1, r0, #0
    4b00:	bf18      	it	ne
    4b02:	2101      	movne	r1, #1
    4b04:	20fe      	movs	r0, #254	; 0xfe
    4b06:	f7ff bf95 	b.w	4a34 <USBHwCmdWrite>

00004b0a <USBHwNakIntEnable>:
    
    @param [in] bIntBits    Bitmap indicating which NAK interrupts to enable
 */
void USBHwNakIntEnable(U8 bIntBits)
{
    USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
    4b0a:	4601      	mov	r1, r0
    4b0c:	20f3      	movs	r0, #243	; 0xf3
    4b0e:	f7ff bf91 	b.w	4a34 <USBHwCmdWrite>
    4b12:	0000      	movs	r0, r0

00004b14 <USBHwEPGetStatus>:
        
    @param [in] bEP     Endpoint number
    @return Endpoint status byte (containing EP_STATUS_xxx bits)
 */
U8  USBHwEPGetStatus(U8 bEP)
{
    4b14:	b510      	push	{r4, lr}
    int idx = EP2IDX(bEP);
    4b16:	f000 040f 	and.w	r4, r0, #15
    4b1a:	09c0      	lsrs	r0, r0, #7
    4b1c:	ea40 0444 	orr.w	r4, r0, r4, lsl #1
    @return the data
 */
static U8 USBHwCmdRead(U8 bCmd)
{
    // write command code
    USBHwCmd(bCmd);
    4b20:	4620      	mov	r0, r4
    4b22:	f7ff ff7b 	bl	4a1c <USBHwCmd>
    
    // get data
    USBCmdCode = 0x00000200 | (bCmd << 16);
    4b26:	0424      	lsls	r4, r4, #16
    4b28:	4b05      	ldr	r3, [pc, #20]	; (4b40 <USBHwEPGetStatus+0x2c>)
    4b2a:	f444 7400 	orr.w	r4, r4, #512	; 0x200
    4b2e:	601c      	str	r4, [r3, #0]
    Wait4DevInt(CDFULL);
    4b30:	2020      	movs	r0, #32
    4b32:	f7ff ff67 	bl	4a04 <Wait4DevInt>
    return USBCmdData;
    4b36:	4b03      	ldr	r3, [pc, #12]	; (4b44 <USBHwEPGetStatus+0x30>)
    4b38:	6818      	ldr	r0, [r3, #0]
U8  USBHwEPGetStatus(U8 bEP)
{
    int idx = EP2IDX(bEP);

    return USBHwCmdRead(CMD_EP_SELECT | idx);
}
    4b3a:	b2c0      	uxtb	r0, r0
    4b3c:	bd10      	pop	{r4, pc}
    4b3e:	bf00      	nop
    4b40:	5000c210 	.word	0x5000c210
    4b44:	5000c214 	.word	0x5000c214

00004b48 <USBHwEPStall>:
    @param [in] bEP     Endpoint number
    @param [in] fStall  TRUE to stall, FALSE to unstall
 */
void USBHwEPStall(U8 bEP, BOOL fStall)
{
    int idx = EP2IDX(bEP);
    4b48:	f000 030f 	and.w	r3, r0, #15
    4b4c:	09c0      	lsrs	r0, r0, #7
    4b4e:	ea40 0043 	orr.w	r0, r0, r3, lsl #1

    USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
    4b52:	3100      	adds	r1, #0
    4b54:	f040 0040 	orr.w	r0, r0, #64	; 0x40
    4b58:	bf18      	it	ne
    4b5a:	2101      	movne	r1, #1
    4b5c:	f7ff bf6a 	b.w	4a34 <USBHwCmdWrite>

00004b60 <USBHwEPWrite>:
    @param [in] iLen    Number of bytes to write
            
    @return number of bytes written into the endpoint buffer
*/
int USBHwEPWrite(U8 bEP, U8 *pbBuf, U32 iLen)
{
    4b60:	b538      	push	{r3, r4, r5, lr}
    4b62:	4615      	mov	r5, r2
    U32 idx;
    
    idx = EP2IDX(bEP);
    4b64:	f000 030f 	and.w	r3, r0, #15
    4b68:	09c0      	lsrs	r0, r0, #7
    4b6a:	ea40 0043 	orr.w	r0, r0, r3, lsl #1
    
    // set write enable for specific endpoint
    USBCtrl = WR_EN | ((bEP & 0xF) << 2);
    4b6e:	4a13      	ldr	r2, [pc, #76]	; (4bbc <USBHwEPWrite+0x5c>)
    4b70:	009b      	lsls	r3, r3, #2
    4b72:	f043 0302 	orr.w	r3, r3, #2
    4b76:	6013      	str	r3, [r2, #0]
    
    // set packet length
    USBTxPLen = iLen;
    4b78:	4b11      	ldr	r3, [pc, #68]	; (4bc0 <USBHwEPWrite+0x60>)
    4b7a:	601d      	str	r5, [r3, #0]
    
    // write data
    while (USBCtrl & WR_EN) {
    4b7c:	6813      	ldr	r3, [r2, #0]
    4b7e:	3104      	adds	r1, #4
    4b80:	f013 0302 	ands.w	r3, r3, #2
    4b84:	d010      	beq.n	4ba8 <USBHwEPWrite+0x48>
        USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
    4b86:	f811 3c02 	ldrb.w	r3, [r1, #-2]
    4b8a:	f811 4c01 	ldrb.w	r4, [r1, #-1]
    4b8e:	041b      	lsls	r3, r3, #16
    4b90:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
    4b94:	f811 4c04 	ldrb.w	r4, [r1, #-4]
    4b98:	4323      	orrs	r3, r4
    4b9a:	f811 4c03 	ldrb.w	r4, [r1, #-3]
    4b9e:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    4ba2:	4c08      	ldr	r4, [pc, #32]	; (4bc4 <USBHwEPWrite+0x64>)
    4ba4:	6023      	str	r3, [r4, #0]
    4ba6:	e7e9      	b.n	4b7c <USBHwEPWrite+0x1c>
        pbBuf += 4;
    }

    USBCtrl = 0;
    4ba8:	4a04      	ldr	r2, [pc, #16]	; (4bbc <USBHwEPWrite+0x5c>)
    4baa:	6013      	str	r3, [r2, #0]

    // select endpoint and validate buffer
    USBHwCmd(CMD_EP_SELECT | idx);
    4bac:	f7ff ff36 	bl	4a1c <USBHwCmd>
    USBHwCmd(CMD_EP_VALIDATE_BUFFER);
    4bb0:	20fa      	movs	r0, #250	; 0xfa
    4bb2:	f7ff ff33 	bl	4a1c <USBHwCmd>
    
    return iLen;
}
    4bb6:	4628      	mov	r0, r5
    4bb8:	bd38      	pop	{r3, r4, r5, pc}
    4bba:	bf00      	nop
    4bbc:	5000c228 	.word	0x5000c228
    4bc0:	5000c224 	.word	0x5000c224
    4bc4:	5000c21c 	.word	0x5000c21c

00004bc8 <USBHwEPRead>:
            
    @return the number of bytes available in the EP (possibly more than iMaxLen),
    or <0 in case of error.
 */
int USBHwEPRead(U8 bEP, U8 *pbBuf, U32 iMaxLen)
{
    4bc8:	b570      	push	{r4, r5, r6, lr}
    U32 dwData, dwLen;
    
    idx = EP2IDX(bEP);
    
    // set read enable bit for specific endpoint
    USBCtrl = RD_EN | ((bEP & 0xF) << 2);
    4bca:	4c17      	ldr	r4, [pc, #92]	; (4c28 <USBHwEPRead+0x60>)
int USBHwEPRead(U8 bEP, U8 *pbBuf, U32 iMaxLen)
{
    U32 i, idx;
    U32 dwData, dwLen;
    
    idx = EP2IDX(bEP);
    4bcc:	f000 030f 	and.w	r3, r0, #15
    4bd0:	4626      	mov	r6, r4
    4bd2:	09c0      	lsrs	r0, r0, #7
    4bd4:	ea40 0043 	orr.w	r0, r0, r3, lsl #1
    
    // set read enable bit for specific endpoint
    USBCtrl = RD_EN | ((bEP & 0xF) << 2);
    4bd8:	009b      	lsls	r3, r3, #2
    4bda:	f043 0301 	orr.w	r3, r3, #1
    4bde:	6023      	str	r3, [r4, #0]
    
    // wait for PKT_RDY
    do {
        dwLen = USBRxPLen;
    4be0:	4b12      	ldr	r3, [pc, #72]	; (4c2c <USBHwEPRead+0x64>)
    4be2:	681b      	ldr	r3, [r3, #0]
    } while ((dwLen & PKT_RDY) == 0);
    4be4:	051d      	lsls	r5, r3, #20
    4be6:	d5fb      	bpl.n	4be0 <USBHwEPRead+0x18>
    
    // packet valid?
    if ((dwLen & DV) == 0) {
    4be8:	055c      	lsls	r4, r3, #21
    4bea:	d51a      	bpl.n	4c22 <USBHwEPRead+0x5a>
    
    // get length
    dwLen &= PKT_LNGTH_MASK;
    
    // get data
    dwData = 0;
    4bec:	2500      	movs	r5, #0
    for (i = 0; i < dwLen; i++) {
    4bee:	462c      	mov	r4, r5
    if ((dwLen & DV) == 0) {
        return -1;
    }
    
    // get length
    dwLen &= PKT_LNGTH_MASK;
    4bf0:	f3c3 0309 	ubfx	r3, r3, #0, #10
    
    // get data
    dwData = 0;
    for (i = 0; i < dwLen; i++) {
    4bf4:	429c      	cmp	r4, r3
    4bf6:	d00b      	beq.n	4c10 <USBHwEPRead+0x48>
        if ((i % 4) == 0) {
    4bf8:	f014 0f03 	tst.w	r4, #3
            dwData = USBRxData;
    4bfc:	bf04      	itt	eq
    4bfe:	4d0c      	ldreq	r5, [pc, #48]	; (4c30 <USBHwEPRead+0x68>)
    4c00:	682d      	ldreq	r5, [r5, #0]
        }
        if ((pbBuf != NULL) && (i < iMaxLen)) {
    4c02:	b111      	cbz	r1, 4c0a <USBHwEPRead+0x42>
    4c04:	4294      	cmp	r4, r2
            pbBuf[i] = dwData & 0xFF;
    4c06:	bf38      	it	cc
    4c08:	550d      	strbcc	r5, [r1, r4]
        }
        dwData >>= 8;
    4c0a:	0a2d      	lsrs	r5, r5, #8
    // get length
    dwLen &= PKT_LNGTH_MASK;
    
    // get data
    dwData = 0;
    for (i = 0; i < dwLen; i++) {
    4c0c:	3401      	adds	r4, #1
    4c0e:	e7f1      	b.n	4bf4 <USBHwEPRead+0x2c>
        }
        dwData >>= 8;
    }

    // make sure RD_EN is clear
    USBCtrl = 0;
    4c10:	2300      	movs	r3, #0
    4c12:	6033      	str	r3, [r6, #0]

    // select endpoint and clear buffer
    USBHwCmd(CMD_EP_SELECT | idx);
    4c14:	f7ff ff02 	bl	4a1c <USBHwCmd>
    USBHwCmd(CMD_EP_CLEAR_BUFFER);
    4c18:	20f2      	movs	r0, #242	; 0xf2
    4c1a:	f7ff feff 	bl	4a1c <USBHwCmd>
    
    return dwLen;
    4c1e:	4620      	mov	r0, r4
    4c20:	bd70      	pop	{r4, r5, r6, pc}
        dwLen = USBRxPLen;
    } while ((dwLen & PKT_RDY) == 0);
    
    // packet valid?
    if ((dwLen & DV) == 0) {
        return -1;
    4c22:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    // select endpoint and clear buffer
    USBHwCmd(CMD_EP_SELECT | idx);
    USBHwCmd(CMD_EP_CLEAR_BUFFER);
    
    return dwLen;
}
    4c26:	bd70      	pop	{r4, r5, r6, pc}
    4c28:	5000c228 	.word	0x5000c228
    4c2c:	5000c220 	.word	0x5000c220
    4c30:	5000c218 	.word	0x5000c218

00004c34 <USBHwConfigDevice>:
    @param [in] fConfigured If TRUE, configure device, else unconfigure
 */
void USBHwConfigDevice(BOOL fConfigured)
{
    // set configured bit
    USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
    4c34:	1c01      	adds	r1, r0, #0
    4c36:	bf18      	it	ne
    4c38:	2101      	movne	r1, #1
    4c3a:	20d8      	movs	r0, #216	; 0xd8
    4c3c:	f7ff befa 	b.w	4a34 <USBHwCmdWrite>

00004c40 <USBHwISR>:
    @todo Get all 11 bits of frame number instead of just 8

    Endpoint interrupts are mapped to the slow interrupt
 */
void USBHwISR(void)
{
    4c40:	b538      	push	{r3, r4, r5, lr}

// LED9 monitors total time in interrupt routine
DEBUG_LED_ON(9);

    // handle device interrupts
    dwStatus = USBDevIntSt;
    4c42:	4b29      	ldr	r3, [pc, #164]	; (4ce8 <USBHwISR+0xa8>)
    4c44:	681c      	ldr	r4, [r3, #0]
    
    // frame interrupt
    if (dwStatus & FRAME) {
    4c46:	07e1      	lsls	r1, r4, #31
    4c48:	d511      	bpl.n	4c6e <USBHwISR+0x2e>
        // clear int
        USBDevIntClr = FRAME;
    4c4a:	2201      	movs	r2, #1
    4c4c:	609a      	str	r2, [r3, #8]
        // call handler
        if (_pfnFrameHandler != NULL) {
    4c4e:	4b27      	ldr	r3, [pc, #156]	; (4cec <USBHwISR+0xac>)
    4c50:	6c5d      	ldr	r5, [r3, #68]	; 0x44
    4c52:	b165      	cbz	r5, 4c6e <USBHwISR+0x2e>
    @return the data
 */
static U8 USBHwCmdRead(U8 bCmd)
{
    // write command code
    USBHwCmd(bCmd);
    4c54:	20f5      	movs	r0, #245	; 0xf5
    4c56:	f7ff fee1 	bl	4a1c <USBHwCmd>
    
    // get data
    USBCmdCode = 0x00000200 | (bCmd << 16);
    4c5a:	4b25      	ldr	r3, [pc, #148]	; (4cf0 <USBHwISR+0xb0>)
    4c5c:	4a25      	ldr	r2, [pc, #148]	; (4cf4 <USBHwISR+0xb4>)
    Wait4DevInt(CDFULL);
    4c5e:	2020      	movs	r0, #32
{
    // write command code
    USBHwCmd(bCmd);
    
    // get data
    USBCmdCode = 0x00000200 | (bCmd << 16);
    4c60:	601a      	str	r2, [r3, #0]
    Wait4DevInt(CDFULL);
    4c62:	f7ff fecf 	bl	4a04 <Wait4DevInt>
    return USBCmdData;
    4c66:	4b24      	ldr	r3, [pc, #144]	; (4cf8 <USBHwISR+0xb8>)
    4c68:	6818      	ldr	r0, [r3, #0]
        // clear int
        USBDevIntClr = FRAME;
        // call handler
        if (_pfnFrameHandler != NULL) {
            wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
            _pfnFrameHandler(wFrame);
    4c6a:	b2c0      	uxtb	r0, r0
    4c6c:	47a8      	blx	r5
        }
    }
    
    // device status interrupt
    if (dwStatus & DEV_STAT) {
    4c6e:	0722      	lsls	r2, r4, #28
    4c70:	d517      	bpl.n	4ca2 <USBHwISR+0x62>
        /*  Clear DEV_STAT interrupt before reading DEV_STAT register.
            This prevents corrupted device status reads, see
            LPC2148 User manual revision 2, 25 july 2006.
        */
        USBDevIntClr = DEV_STAT;
    4c72:	4b22      	ldr	r3, [pc, #136]	; (4cfc <USBHwISR+0xbc>)
    4c74:	2208      	movs	r2, #8
    4c76:	601a      	str	r2, [r3, #0]
    @return the data
 */
static U8 USBHwCmdRead(U8 bCmd)
{
    // write command code
    USBHwCmd(bCmd);
    4c78:	20fe      	movs	r0, #254	; 0xfe
    4c7a:	f7ff fecf 	bl	4a1c <USBHwCmd>
    
    // get data
    USBCmdCode = 0x00000200 | (bCmd << 16);
    4c7e:	4b1c      	ldr	r3, [pc, #112]	; (4cf0 <USBHwISR+0xb0>)
    4c80:	4a1f      	ldr	r2, [pc, #124]	; (4d00 <USBHwISR+0xc0>)
    Wait4DevInt(CDFULL);
    4c82:	2020      	movs	r0, #32
{
    // write command code
    USBHwCmd(bCmd);
    
    // get data
    USBCmdCode = 0x00000200 | (bCmd << 16);
    4c84:	601a      	str	r2, [r3, #0]
    Wait4DevInt(CDFULL);
    4c86:	f7ff febd 	bl	4a04 <Wait4DevInt>
    return USBCmdData;
    4c8a:	4b1b      	ldr	r3, [pc, #108]	; (4cf8 <USBHwISR+0xb8>)
    4c8c:	6818      	ldr	r0, [r3, #0]
    4c8e:	b2c0      	uxtb	r0, r0
            This prevents corrupted device status reads, see
            LPC2148 User manual revision 2, 25 july 2006.
        */
        USBDevIntClr = DEV_STAT;
        bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
        if (bDevStat & (CON_CH | SUS_CH | RST)) {
    4c90:	f010 0f1a 	tst.w	r0, #26
    4c94:	d005      	beq.n	4ca2 <USBHwISR+0x62>
            // convert device status into something HW independent
            bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
                    ((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
                    ((bDevStat & RST) ? DEV_STATUS_RESET : 0);
            // call handler
            if (_pfnDevIntHandler != NULL) {
    4c96:	4b15      	ldr	r3, [pc, #84]	; (4cec <USBHwISR+0xac>)
    4c98:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4c9a:	b113      	cbz	r3, 4ca2 <USBHwISR+0x62>
DEBUG_LED_ON(8);        
                _pfnDevIntHandler(bStat);
    4c9c:	f000 0015 	and.w	r0, r0, #21
    4ca0:	4798      	blx	r3
            }
        }
    }
    
    // endpoint interrupt
    if (dwStatus & EP_SLOW) {
    4ca2:	0763      	lsls	r3, r4, #29
    4ca4:	d51e      	bpl.n	4ce4 <USBHwISR+0xa4>
        // clear EP_SLOW
        USBDevIntClr = EP_SLOW;
    4ca6:	4b15      	ldr	r3, [pc, #84]	; (4cfc <USBHwISR+0xbc>)
    4ca8:	2204      	movs	r2, #4
    4caa:	601a      	str	r2, [r3, #0]
        // check all endpoints
        for (i = 0; i < 32; i++) {
    4cac:	2400      	movs	r4, #0
            dwIntBit = (1 << i);
            if (USBEpIntSt & dwIntBit) {
    4cae:	4a15      	ldr	r2, [pc, #84]	; (4d04 <USBHwISR+0xc4>)
    if (dwStatus & EP_SLOW) {
        // clear EP_SLOW
        USBDevIntClr = EP_SLOW;
        // check all endpoints
        for (i = 0; i < 32; i++) {
            dwIntBit = (1 << i);
    4cb0:	2301      	movs	r3, #1
            if (USBEpIntSt & dwIntBit) {
    4cb2:	6812      	ldr	r2, [r2, #0]
    if (dwStatus & EP_SLOW) {
        // clear EP_SLOW
        USBDevIntClr = EP_SLOW;
        // check all endpoints
        for (i = 0; i < 32; i++) {
            dwIntBit = (1 << i);
    4cb4:	40a3      	lsls	r3, r4
            if (USBEpIntSt & dwIntBit) {
    4cb6:	4213      	tst	r3, r2
    4cb8:	d011      	beq.n	4cde <USBHwISR+0x9e>
                // clear int (and retrieve status)
                USBEpIntClr = dwIntBit;
    4cba:	4a13      	ldr	r2, [pc, #76]	; (4d08 <USBHwISR+0xc8>)
                Wait4DevInt(CDFULL);
    4cbc:	2020      	movs	r0, #32
        // check all endpoints
        for (i = 0; i < 32; i++) {
            dwIntBit = (1 << i);
            if (USBEpIntSt & dwIntBit) {
                // clear int (and retrieve status)
                USBEpIntClr = dwIntBit;
    4cbe:	6013      	str	r3, [r2, #0]
                Wait4DevInt(CDFULL);
    4cc0:	f7ff fea0 	bl	4a04 <Wait4DevInt>
                bEPStat = USBCmdData;
    4cc4:	4b0c      	ldr	r3, [pc, #48]	; (4cf8 <USBHwISR+0xb8>)
                        ((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
                        ((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
                        ((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
                        ((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
                // call handler
                if (_apfnEPIntHandlers[i / 2] != NULL) {
    4cc6:	1060      	asrs	r0, r4, #1
            dwIntBit = (1 << i);
            if (USBEpIntSt & dwIntBit) {
                // clear int (and retrieve status)
                USBEpIntClr = dwIntBit;
                Wait4DevInt(CDFULL);
                bEPStat = USBCmdData;
    4cc8:	6819      	ldr	r1, [r3, #0]
                        ((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
                        ((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
                        ((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
                        ((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
                // call handler
                if (_apfnEPIntHandlers[i / 2] != NULL) {
    4cca:	4b08      	ldr	r3, [pc, #32]	; (4cec <USBHwISR+0xac>)
    4ccc:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    4cd0:	b12b      	cbz	r3, 4cde <USBHwISR+0x9e>
DEBUG_LED_ON(10);       
                    _apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
    4cd2:	ea40 10c4 	orr.w	r0, r0, r4, lsl #7
    4cd6:	b2c0      	uxtb	r0, r0
    4cd8:	f001 011f 	and.w	r1, r1, #31
    4cdc:	4798      	blx	r3
    // endpoint interrupt
    if (dwStatus & EP_SLOW) {
        // clear EP_SLOW
        USBDevIntClr = EP_SLOW;
        // check all endpoints
        for (i = 0; i < 32; i++) {
    4cde:	3401      	adds	r4, #1
    4ce0:	2c20      	cmp	r4, #32
    4ce2:	d1e4      	bne.n	4cae <USBHwISR+0x6e>
    4ce4:	bd38      	pop	{r3, r4, r5, pc}
    4ce6:	bf00      	nop
    4ce8:	5000c200 	.word	0x5000c200
    4cec:	10000790 	.word	0x10000790
    4cf0:	5000c210 	.word	0x5000c210
    4cf4:	00f50200 	.word	0x00f50200
    4cf8:	5000c214 	.word	0x5000c214
    4cfc:	5000c208 	.word	0x5000c208
    4d00:	00fe0200 	.word	0x00fe0200
    4d04:	5000c230 	.word	0x5000c230
    4d08:	5000c238 	.word	0x5000c238

00004d0c <USBHwInit>:
    acts as a pull-up and so prevents detection of USB disconnect.
        
    @return TRUE if the hardware was successfully initialised
 */
BOOL USBHwInit(void)
{
    4d0c:	b508      	push	{r3, lr}
#ifdef LPC17xx
	// P2.9 is USB_CONNECT
    PINSEL4 = (PINSEL4 & ~(3 << 18)) | (1 << 18);
    4d0e:	4a25      	ldr	r2, [pc, #148]	; (4da4 <USBHwInit+0x98>)
    4d10:	6813      	ldr	r3, [r2, #0]
    4d12:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
    4d16:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    4d1a:	6013      	str	r3, [r2, #0]

	// P1.18 is USB_UP_LED
    PINSEL3 = (PINSEL3 & ~(3 << 4)) | (1 << 4);
    4d1c:	f852 3c04 	ldr.w	r3, [r2, #-4]
    4d20:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    4d24:	f043 0310 	orr.w	r3, r3, #16
    4d28:	f842 3c04 	str.w	r3, [r2, #-4]

	// P1.30 is VBUS
    PINSEL3 = (PINSEL3 & ~(3 << 28)) | (2 << 28);
    4d2c:	f852 3c04 	ldr.w	r3, [r2, #-4]
    4d30:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
    4d34:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
    4d38:	f842 3c04 	str.w	r3, [r2, #-4]

	// P0.29 is USB_D+
    PINSEL1 = (PINSEL1 & ~(3 << 26)) | (1 << 26);
    4d3c:	f852 3c0c 	ldr.w	r3, [r2, #-12]
    4d40:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
    4d44:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    4d48:	f842 3c0c 	str.w	r3, [r2, #-12]

	// P0.30 is USB_D-
    PINSEL1 = (PINSEL1 & ~(3 << 28)) | (1 << 28);
    4d4c:	f852 3c0c 	ldr.w	r3, [r2, #-12]
    4d50:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
    4d54:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    4d58:	f842 3c0c 	str.w	r3, [r2, #-12]

	// enable PUSB
	PCONP |= PCONP_PCUSB;
    4d5c:	f502 2250 	add.w	r2, r2, #851968	; 0xd0000
    4d60:	32b4      	adds	r2, #180	; 0xb4
    4d62:	6813      	ldr	r3, [r2, #0]
    4d64:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    4d68:	6013      	str	r3, [r2, #0]

	/* enable the USB controller clocks */
    USBClkCtrl |= (USBClkCtrl_DEV_CLK_EN | USBClkCtrl_AHB_CLK_EN);
    4d6a:	4a0f      	ldr	r2, [pc, #60]	; (4da8 <USBHwInit+0x9c>)
    4d6c:	6813      	ldr	r3, [r2, #0]
    4d6e:	f043 0312 	orr.w	r3, r3, #18
    4d72:	6013      	str	r3, [r2, #0]
    while (!(USBClkSt & USBClkSt_DEV_CLK_ON));
    4d74:	4b0d      	ldr	r3, [pc, #52]	; (4dac <USBHwInit+0xa0>)
    4d76:	681a      	ldr	r2, [r3, #0]
    4d78:	0791      	lsls	r1, r2, #30
    4d7a:	d5fb      	bpl.n	4d74 <USBHwInit+0x68>
    while (!(USBClkSt & USBClkSt_AHB_CLK_ON));
    4d7c:	681a      	ldr	r2, [r3, #0]
    4d7e:	06d2      	lsls	r2, r2, #27
    4d80:	d5fc      	bpl.n	4d7c <USBHwInit+0x70>
#endif

#endif
    
    // disable/clear all interrupts for now
    USBDevIntEn = 0;
    4d82:	4b0b      	ldr	r3, [pc, #44]	; (4db0 <USBHwInit+0xa4>)
    4d84:	2000      	movs	r0, #0
    USBDevIntClr = 0xFFFFFFFF;
    4d86:	4a0b      	ldr	r2, [pc, #44]	; (4db4 <USBHwInit+0xa8>)
#endif

#endif
    
    // disable/clear all interrupts for now
    USBDevIntEn = 0;
    4d88:	6018      	str	r0, [r3, #0]
    USBDevIntClr = 0xFFFFFFFF;
    4d8a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    4d8e:	6013      	str	r3, [r2, #0]
    USBDevIntPri = 0;
    4d90:	6250      	str	r0, [r2, #36]	; 0x24

    USBEpIntEn = 0;
    4d92:	62d0      	str	r0, [r2, #44]	; 0x2c
    USBEpIntClr = 0xFFFFFFFF;
    4d94:	6313      	str	r3, [r2, #48]	; 0x30
    USBEpIntPri = 0;
    4d96:	4b08      	ldr	r3, [pc, #32]	; (4db8 <USBHwInit+0xac>)
    4d98:	6018      	str	r0, [r3, #0]

    // by default, only ACKs generate interrupts
    USBHwNakIntEnable(0);
    4d9a:	f7ff feb6 	bl	4b0a <USBHwNakIntEnable>
    DEBUG_LED_INIT(8);
    DEBUG_LED_INIT(9);
    DEBUG_LED_INIT(10);

    return TRUE;
}
    4d9e:	2001      	movs	r0, #1
    4da0:	bd08      	pop	{r3, pc}
    4da2:	bf00      	nop
    4da4:	4002c010 	.word	0x4002c010
    4da8:	5000cff4 	.word	0x5000cff4
    4dac:	5000cff8 	.word	0x5000cff8
    4db0:	5000c204 	.word	0x5000c204
    4db4:	5000c208 	.word	0x5000c208
    4db8:	5000c240 	.word	0x5000c240

00004dbc <USBFilterOsVendorMessage>:
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the request was handled by this filter, FALSE otherwise
 */
BOOL USBFilterOsVendorMessage(TSetupPacket *pSetup, BOOL *pfSuccess, int *piLen, U8 **ppbData)
{
    4dbc:	b570      	push	{r4, r5, r6, lr}
	if(bMsVendorIndex == 0)	{
    4dbe:	4c16      	ldr	r4, [pc, #88]	; (4e18 <USBFilterOsVendorMessage+0x5c>)
    4dc0:	7825      	ldrb	r5, [r4, #0]
    4dc2:	2400      	movs	r4, #0
    4dc4:	b315      	cbz	r5, 4e0c <USBFilterOsVendorMessage+0x50>
		// Feature is disabled.
		return FALSE;
	}
	
	if(pSetup->bRequest == bMsVendorIndex) {
    4dc6:	7846      	ldrb	r6, [r0, #1]
    4dc8:	42ae      	cmp	r6, r5
    4dca:	d121      	bne.n	4e10 <USBFilterOsVendorMessage+0x54>
		// Fail unless we make it to the end.
		*pfSuccess = FALSE;
    4dcc:	600c      	str	r4, [r1, #0]
	
		int iRequestLength = pSetup->wLength;
    4dce:	88c6      	ldrh	r6, [r0, #6]
		U8 bInterfaceNumber = GET_OS_DESC_INTERFACE(pSetup->wValue);
		U8 bPageNumber = GET_OS_DESC_PAGE(pSetup->wValue);
    4dd0:	8844      	ldrh	r4, [r0, #2]
	
		switch (pSetup->wIndex) {
    4dd2:	8880      	ldrh	r0, [r0, #4]
    4dd4:	2804      	cmp	r0, #4
    4dd6:	d005      	beq.n	4de4 <USBFilterOsVendorMessage+0x28>
    4dd8:	2805      	cmp	r0, #5
    4dda:	d11b      	bne.n	4e14 <USBFilterOsVendorMessage+0x58>
			*ppbData = (U8*)abExtendedOsFeatureDescriptor;
			*piLen = sizeof(abExtendedOsFeatureDescriptor);
			break;
			
		case DESC_EXT_OS_PROPERTIES:
			*ppbData = abExtendedPropertiesFeatureDescriptor;
    4ddc:	480f      	ldr	r0, [pc, #60]	; (4e1c <USBFilterOsVendorMessage+0x60>)
    4dde:	6018      	str	r0, [r3, #0]
			*piLen = sizeof(abExtendedPropertiesFeatureDescriptor);			
    4de0:	2092      	movs	r0, #146	; 0x92
    4de2:	e002      	b.n	4dea <USBFilterOsVendorMessage+0x2e>
		U8 bInterfaceNumber = GET_OS_DESC_INTERFACE(pSetup->wValue);
		U8 bPageNumber = GET_OS_DESC_PAGE(pSetup->wValue);
	
		switch (pSetup->wIndex) {
		case DESC_EXT_OS_FEATURES:
			*ppbData = (U8*)abExtendedOsFeatureDescriptor;
    4de4:	480e      	ldr	r0, [pc, #56]	; (4e20 <USBFilterOsVendorMessage+0x64>)
    4de6:	6018      	str	r0, [r3, #0]
			*piLen = sizeof(abExtendedOsFeatureDescriptor);
    4de8:	2028      	movs	r0, #40	; 0x28
			break;
			
		case DESC_EXT_OS_PROPERTIES:
			*ppbData = abExtendedPropertiesFeatureDescriptor;
			*piLen = sizeof(abExtendedPropertiesFeatureDescriptor);			
    4dea:	6010      	str	r0, [r2, #0]
		default:
			return TRUE;
		}
		
		// Decide what portion of the descriptor to return.
		int iPageOffset = bPageNumber*0x10000; // This will probably always be zero...
    4dec:	0a20      	lsrs	r0, r4, #8
		if (*piLen < iPageOffset) {
    4dee:	6814      	ldr	r4, [r2, #0]
		default:
			return TRUE;
		}
		
		// Decide what portion of the descriptor to return.
		int iPageOffset = bPageNumber*0x10000; // This will probably always be zero...
    4df0:	0400      	lsls	r0, r0, #16
		if (*piLen < iPageOffset) {
    4df2:	4284      	cmp	r4, r0
    4df4:	db0e      	blt.n	4e14 <USBFilterOsVendorMessage+0x58>
			// Not enough data for the requested offset.
			return TRUE;
		}
		*ppbData += iPageOffset;
    4df6:	681d      	ldr	r5, [r3, #0]
    4df8:	4405      	add	r5, r0
		*piLen -= iPageOffset;
    4dfa:	1a20      	subs	r0, r4, r0
		int iPageOffset = bPageNumber*0x10000; // This will probably always be zero...
		if (*piLen < iPageOffset) {
			// Not enough data for the requested offset.
			return TRUE;
		}
		*ppbData += iPageOffset;
    4dfc:	601d      	str	r5, [r3, #0]
    4dfe:	42b0      	cmp	r0, r6
    4e00:	bfd4      	ite	le
    4e02:	6010      	strle	r0, [r2, #0]
    4e04:	6016      	strgt	r6, [r2, #0]
		if (*piLen > iRequestLength) {
			// Clip data longer than the requested length
			*piLen = iRequestLength;
		}
	
		*pfSuccess = TRUE;
    4e06:	2001      	movs	r0, #1
    4e08:	6008      	str	r0, [r1, #0]
		return TRUE;
    4e0a:	bd70      	pop	{r4, r5, r6, pc}
 */
BOOL USBFilterOsVendorMessage(TSetupPacket *pSetup, BOOL *pfSuccess, int *piLen, U8 **ppbData)
{
	if(bMsVendorIndex == 0)	{
		// Feature is disabled.
		return FALSE;
    4e0c:	4628      	mov	r0, r5
    4e0e:	bd70      	pop	{r4, r5, r6, pc}
    4e10:	4620      	mov	r0, r4
    4e12:	bd70      	pop	{r4, r5, r6, pc}
		
		// Decide what portion of the descriptor to return.
		int iPageOffset = bPageNumber*0x10000; // This will probably always be zero...
		if (*piLen < iPageOffset) {
			// Not enough data for the requested offset.
			return TRUE;
    4e14:	2001      	movs	r0, #1
		return TRUE;
	}
	
	// These are not the requests you are looking for
	return FALSE;
}
    4e16:	bd70      	pop	{r4, r5, r6, pc}
    4e18:	100007d8 	.word	0x100007d8
    4e1c:	10000524 	.word	0x10000524
    4e20:	000050b4 	.word	0x000050b4

00004e24 <USBRegisterDescriptors>:

	@param [in]	pabDescriptors	The descriptor byte array
 */
void USBRegisterDescriptors(U8 *pabDescriptors)
{
	pabDescrip = pabDescriptors;
    4e24:	4b01      	ldr	r3, [pc, #4]	; (4e2c <USBRegisterDescriptors+0x8>)
    4e26:	6058      	str	r0, [r3, #4]
    4e28:	4770      	bx	lr
    4e2a:	bf00      	nop
    4e2c:	100007d8 	.word	0x100007d8

00004e30 <USBGetDescriptor>:
	@param [out]	*ppbData	Descriptor data
	
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetDescriptor(U16 wTypeIndex, U16 wLangID, int *piLen, U8 **ppbData)
{
    4e30:	b5f0      	push	{r4, r5, r6, r7, lr}
	U8	*pab;
	int iCurIndex;
	
	ASSERT(pabDescrip != NULL);

	bType = GET_DESC_TYPE(wTypeIndex);
    4e32:	0a06      	lsrs	r6, r0, #8
	bIndex = GET_DESC_INDEX(wTypeIndex);
	
    if (bType == DESC_STRING &&
    4e34:	2e03      	cmp	r6, #3
	int iCurIndex;
	
	ASSERT(pabDescrip != NULL);

	bType = GET_DESC_TYPE(wTypeIndex);
	bIndex = GET_DESC_INDEX(wTypeIndex);
    4e36:	b2c4      	uxtb	r4, r0
    4e38:	4811      	ldr	r0, [pc, #68]	; (4e80 <USBGetDescriptor+0x50>)
	
    if (bType == DESC_STRING &&
    4e3a:	d108      	bne.n	4e4e <USBGetDescriptor+0x1e>
    4e3c:	2cee      	cmp	r4, #238	; 0xee
    4e3e:	d106      	bne.n	4e4e <USBGetDescriptor+0x1e>
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetOsStringDescriptor(int *piLen, U8 **ppbData)
{
	// The last character in the OS String descriptor specifies the vendor request index to use.
	abOsStringDescriptor[sizeof(abOsStringDescriptor)-2] = bMsVendorIndex;
    4e40:	4910      	ldr	r1, [pc, #64]	; (4e84 <USBGetDescriptor+0x54>)
    4e42:	7800      	ldrb	r0, [r0, #0]
	
	*ppbData = abOsStringDescriptor;
    4e44:	3192      	adds	r1, #146	; 0x92
	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetOsStringDescriptor(int *piLen, U8 **ppbData)
{
	// The last character in the OS String descriptor specifies the vendor request index to use.
	abOsStringDescriptor[sizeof(abOsStringDescriptor)-2] = bMsVendorIndex;
    4e46:	7408      	strb	r0, [r1, #16]
	
	*ppbData = abOsStringDescriptor;
    4e48:	6019      	str	r1, [r3, #0]
	*piLen = sizeof(abOsStringDescriptor);
    4e4a:	2312      	movs	r3, #18
    4e4c:	e012      	b.n	4e74 <USBGetDescriptor+0x44>
            return TRUE;
        }
    }
    	
	
	pab = (U8 *)pabDescrip;
    4e4e:	6841      	ldr	r1, [r0, #4]
	iCurIndex = 0;
    4e50:	2500      	movs	r5, #0
	
	while (pab[DESC_bLength] != 0) {
    4e52:	e001      	b.n	4e58 <USBGetDescriptor+0x28>
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
				}
				return TRUE;
			}
			iCurIndex++;
    4e54:	3501      	adds	r5, #1
		}
		// skip to next descriptor
		pab += pab[DESC_bLength];
    4e56:	4401      	add	r1, r0
    	
	
	pab = (U8 *)pabDescrip;
	iCurIndex = 0;
	
	while (pab[DESC_bLength] != 0) {
    4e58:	7808      	ldrb	r0, [r1, #0]
    4e5a:	b180      	cbz	r0, 4e7e <USBGetDescriptor+0x4e>
		if (pab[DESC_bDescriptorType] == bType) {
    4e5c:	784f      	ldrb	r7, [r1, #1]
    4e5e:	42b7      	cmp	r7, r6
    4e60:	d1f9      	bne.n	4e56 <USBGetDescriptor+0x26>
			if (iCurIndex == bIndex) {
    4e62:	42a5      	cmp	r5, r4
    4e64:	d1f6      	bne.n	4e54 <USBGetDescriptor+0x24>
				// set data pointer
				*ppbData = pab;
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
    4e66:	2e02      	cmp	r6, #2
	
	while (pab[DESC_bLength] != 0) {
		if (pab[DESC_bDescriptorType] == bType) {
			if (iCurIndex == bIndex) {
				// set data pointer
				*ppbData = pab;
    4e68:	6019      	str	r1, [r3, #0]
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
    4e6a:	d106      	bne.n	4e7a <USBGetDescriptor+0x4a>
					// configuration descriptor is an exception, length is at offset 2 and 3
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
								(pab[CONF_DESC_wTotalLength + 1] << 8);
    4e6c:	78c8      	ldrb	r0, [r1, #3]
				// set data pointer
				*ppbData = pab;
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
					// configuration descriptor is an exception, length is at offset 2 and 3
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
    4e6e:	788b      	ldrb	r3, [r1, #2]
    4e70:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    4e74:	6013      	str	r3, [r2, #0]
				}
				else {
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
				}
				return TRUE;
    4e76:	2001      	movs	r0, #1
    4e78:	bdf0      	pop	{r4, r5, r6, r7, pc}
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
								(pab[CONF_DESC_wTotalLength + 1] << 8);
				}
				else {
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
    4e7a:	780b      	ldrb	r3, [r1, #0]
    4e7c:	e7fa      	b.n	4e74 <USBGetDescriptor+0x44>
		pab += pab[DESC_bLength];
	}
	// nothing found
	DBG("Desc %x not found!\n", wTypeIndex);
	return FALSE;
}
    4e7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4e80:	100007d8 	.word	0x100007d8
    4e84:	10000524 	.word	0x10000524

00004e88 <USBHandleStandardRequest>:
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
    4e88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    4e8c:	4e4b      	ldr	r6, [pc, #300]	; (4fbc <USBHandleStandardRequest+0x134>)
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
    4e8e:	4605      	mov	r5, r0
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    4e90:	68b3      	ldr	r3, [r6, #8]
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
    4e92:	460f      	mov	r7, r1
    4e94:	4614      	mov	r4, r2
    4e96:	46b0      	mov	r8, r6
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    4e98:	b943      	cbnz	r3, 4eac <USBHandleStandardRequest+0x24>
		return TRUE;
	}
	
	switch (REQTYPE_GET_RECIP(pSetup->bmRequestType)) {
    4e9a:	7828      	ldrb	r0, [r5, #0]
    4e9c:	f000 061f 	and.w	r6, r0, #31
    4ea0:	2e01      	cmp	r6, #1
    4ea2:	d055      	beq.n	4f50 <USBHandleStandardRequest+0xc8>
    4ea4:	d306      	bcc.n	4eb4 <USBHandleStandardRequest+0x2c>
    4ea6:	2e02      	cmp	r6, #2
    4ea8:	d064      	beq.n	4f74 <USBHandleStandardRequest+0xec>
    4eaa:	e083      	b.n	4fb4 <USBHandleStandardRequest+0x12c>
	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    4eac:	4798      	blx	r3
    4eae:	2800      	cmp	r0, #0
    4eb0:	d0f3      	beq.n	4e9a <USBHandleStandardRequest+0x12>
    4eb2:	e04a      	b.n	4f4a <USBHandleStandardRequest+0xc2>
 */
static BOOL HandleStdDeviceReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
    4eb4:	786a      	ldrb	r2, [r5, #1]

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdDeviceReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;
    4eb6:	6823      	ldr	r3, [r4, #0]

	switch (pSetup->bRequest) {
    4eb8:	2a09      	cmp	r2, #9
    4eba:	d87b      	bhi.n	4fb4 <USBHandleStandardRequest+0x12c>
    4ebc:	e8df f002 	tbb	[pc, r2]
    4ec0:	7a7a7a05 	.word	0x7a7a7a05
    4ec4:	7a0d097a 	.word	0x7a0d097a
    4ec8:	1c15      	.short	0x1c15
	
	case REQ_GET_STATUS:
		// bit 0: self-powered
		// bit 1: remote wakeup = not supported
		pbData[0] = 0;
    4eca:	2200      	movs	r2, #0
    4ecc:	701a      	strb	r2, [r3, #0]
		pbData[1] = 0;
    4ece:	705a      	strb	r2, [r3, #1]
    4ed0:	e047      	b.n	4f62 <USBHandleStandardRequest+0xda>
		*piLen = 2;
		break;
		
	case REQ_SET_ADDRESS:
		USBHwSetAddress(pSetup->wValue);
    4ed2:	78a8      	ldrb	r0, [r5, #2]
    4ed4:	f7ff fe0e 	bl	4af4 <USBHwSetAddress>
    4ed8:	e037      	b.n	4f4a <USBHandleStandardRequest+0xc2>
		break;

	case REQ_GET_DESCRIPTOR:
		DBG("D%x", pSetup->wValue);
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
    4eda:	8868      	ldrh	r0, [r5, #2]
    4edc:	88a9      	ldrh	r1, [r5, #4]
    4ede:	463a      	mov	r2, r7
    4ee0:	4623      	mov	r3, r4
	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
	default: 						return FALSE;
	}
}
    4ee2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		USBHwSetAddress(pSetup->wValue);
		break;

	case REQ_GET_DESCRIPTOR:
		DBG("D%x", pSetup->wValue);
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
    4ee6:	f7ff bfa3 	b.w	4e30 <USBGetDescriptor>

	case REQ_GET_CONFIGURATION:
		// indicate if we are configured
		pbData[0] = bConfiguration;
    4eea:	f898 200c 	ldrb.w	r2, [r8, #12]
		*piLen = 1;
    4eee:	2001      	movs	r0, #1
		DBG("D%x", pSetup->wValue);
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);

	case REQ_GET_CONFIGURATION:
		// indicate if we are configured
		pbData[0] = bConfiguration;
    4ef0:	701a      	strb	r2, [r3, #0]
		*piLen = 1;
    4ef2:	6038      	str	r0, [r7, #0]
    4ef4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		break;

	case REQ_SET_CONFIGURATION:
		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
    4ef8:	78ae      	ldrb	r6, [r5, #2]
	U8	bEP;
	U16	wMaxPktSize;
	
	ASSERT(pabDescrip != NULL);

	if (bConfigIndex == 0) {
    4efa:	b90e      	cbnz	r6, 4f00 <USBHandleStandardRequest+0x78>
		// unconfigure device
		USBHwConfigDevice(FALSE);
    4efc:	4630      	mov	r0, r6
    4efe:	e01f      	b.n	4f40 <USBHandleStandardRequest+0xb8>
	}
	else {
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
		bCurConfig = 0xFF;
		bCurAltSetting = 0xFF;
    4f00:	27ff      	movs	r7, #255	; 0xff
		USBHwConfigDevice(FALSE);
	}
	else {
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
		bCurConfig = 0xFF;
    4f02:	46b9      	mov	r9, r7
		// unconfigure device
		USBHwConfigDevice(FALSE);
	}
	else {
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
    4f04:	f8d8 4004 	ldr.w	r4, [r8, #4]
		bCurConfig = 0xFF;
		bCurAltSetting = 0xFF;

		while (pab[DESC_bLength] != 0) {
    4f08:	7823      	ldrb	r3, [r4, #0]
    4f0a:	b1c3      	cbz	r3, 4f3e <USBHandleStandardRequest+0xb6>

			switch (pab[DESC_bDescriptorType]) {
    4f0c:	7863      	ldrb	r3, [r4, #1]
    4f0e:	2b04      	cmp	r3, #4
    4f10:	d006      	beq.n	4f20 <USBHandleStandardRequest+0x98>
    4f12:	2b05      	cmp	r3, #5
    4f14:	d006      	beq.n	4f24 <USBHandleStandardRequest+0x9c>
    4f16:	2b02      	cmp	r3, #2
    4f18:	d10e      	bne.n	4f38 <USBHandleStandardRequest+0xb0>

			case DESC_CONFIGURATION:
				// remember current configuration index
				bCurConfig = pab[CONF_DESC_bConfigurationValue];
    4f1a:	f894 9005 	ldrb.w	r9, [r4, #5]
    4f1e:	e00b      	b.n	4f38 <USBHandleStandardRequest+0xb0>
				break;

			case DESC_INTERFACE:
				// remember current alternate setting
				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
    4f20:	78e7      	ldrb	r7, [r4, #3]
    4f22:	e009      	b.n	4f38 <USBHandleStandardRequest+0xb0>
				break;

			case DESC_ENDPOINT:
				if ((bCurConfig == bConfigIndex) &&
    4f24:	45b1      	cmp	r9, r6
    4f26:	d107      	bne.n	4f38 <USBHandleStandardRequest+0xb0>
    4f28:	b937      	cbnz	r7, 4f38 <USBHandleStandardRequest+0xb0>
					(bCurAltSetting == bAltSetting)) {
					// endpoint found for desired config and alternate setting
					bEP = pab[ENDP_DESC_bEndpointAddress];
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
    4f2a:	7961      	ldrb	r1, [r4, #5]
			case DESC_ENDPOINT:
				if ((bCurConfig == bConfigIndex) &&
					(bCurAltSetting == bAltSetting)) {
					// endpoint found for desired config and alternate setting
					bEP = pab[ENDP_DESC_bEndpointAddress];
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
    4f2c:	7923      	ldrb	r3, [r4, #4]
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
					// configure endpoint
					USBHwEPConfig(bEP, wMaxPktSize);
    4f2e:	78a0      	ldrb	r0, [r4, #2]
    4f30:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
    4f34:	f7ff fd8e 	bl	4a54 <USBHwEPConfig>

			default:
				break;
			}
			// skip to next descriptor
			pab += pab[DESC_bLength];
    4f38:	7823      	ldrb	r3, [r4, #0]
    4f3a:	441c      	add	r4, r3
    4f3c:	e7e4      	b.n	4f08 <USBHandleStandardRequest+0x80>
		}
		
		// configure device
		USBHwConfigDevice(TRUE);
    4f3e:	2001      	movs	r0, #1
    4f40:	f7ff fe78 	bl	4c34 <USBHwConfigDevice>
		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
			DBG("USBSetConfiguration failed!\n");
			return FALSE;
		}
		// configuration successful, update current configuration
		bConfiguration = pSetup->wValue & 0xFF;	
    4f44:	886b      	ldrh	r3, [r5, #2]
    4f46:	f888 300c 	strb.w	r3, [r8, #12]
	default:
		DBG("Illegal device req %d\n", pSetup->bRequest);
		return FALSE;
	}
	
	return TRUE;
    4f4a:	2001      	movs	r0, #1
    4f4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 */
static BOOL HandleStdInterfaceReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
    4f50:	786b      	ldrb	r3, [r5, #1]
    4f52:	6822      	ldr	r2, [r4, #0]
    4f54:	2b0a      	cmp	r3, #10
    4f56:	d006      	beq.n	4f66 <USBHandleStandardRequest+0xde>
    4f58:	2b0b      	cmp	r3, #11
    4f5a:	d007      	beq.n	4f6c <USBHandleStandardRequest+0xe4>
    4f5c:	bb53      	cbnz	r3, 4fb4 <USBHandleStandardRequest+0x12c>

	case REQ_GET_STATUS:
		// no bits specified
		pbData[0] = 0;
    4f5e:	7013      	strb	r3, [r2, #0]
		pbData[1] = 0;
    4f60:	7053      	strb	r3, [r2, #1]
		*piLen = 2;
    4f62:	2302      	movs	r3, #2
    4f64:	e004      	b.n	4f70 <USBHandleStandardRequest+0xe8>
		// not defined for interface
		return FALSE;
	
	case REQ_GET_INTERFACE:	// TODO use bNumInterfaces
        // there is only one interface, return n-1 (= 0)
		pbData[0] = 0;
    4f66:	2300      	movs	r3, #0
    4f68:	7013      	strb	r3, [r2, #0]
    4f6a:	e016      	b.n	4f9a <USBHandleStandardRequest+0x112>
		*piLen = 1;
		break;
	
	case REQ_SET_INTERFACE:	// TODO use bNumInterfaces
		// there is only one interface (= 0)
		if (pSetup->wValue != 0) {
    4f6c:	886b      	ldrh	r3, [r5, #2]
    4f6e:	bb0b      	cbnz	r3, 4fb4 <USBHandleStandardRequest+0x12c>
			return FALSE;
		}
		*piLen = 0;
    4f70:	603b      	str	r3, [r7, #0]
    4f72:	e7ea      	b.n	4f4a <USBHandleStandardRequest+0xc2>
    4f74:	f8d4 8000 	ldr.w	r8, [r4]
 */
static BOOL HandleStdEndPointReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
    4f78:	786c      	ldrb	r4, [r5, #1]
    4f7a:	2c01      	cmp	r4, #1
    4f7c:	d00f      	beq.n	4f9e <USBHandleStandardRequest+0x116>
    4f7e:	d302      	bcc.n	4f86 <USBHandleStandardRequest+0xfe>
    4f80:	2c03      	cmp	r4, #3
    4f82:	d010      	beq.n	4fa6 <USBHandleStandardRequest+0x11e>
    4f84:	e016      	b.n	4fb4 <USBHandleStandardRequest+0x12c>
	case REQ_GET_STATUS:
		// bit 0 = endpointed halted or not
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
    4f86:	7928      	ldrb	r0, [r5, #4]
    4f88:	f7ff fdc4 	bl	4b14 <USBHwEPGetStatus>
		pbData[1] = 0;
    4f8c:	2300      	movs	r3, #0
	U8	*pbData = *ppbData;

	switch (pSetup->bRequest) {
	case REQ_GET_STATUS:
		// bit 0 = endpointed halted or not
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
    4f8e:	f3c0 0040 	ubfx	r0, r0, #1, #1
    4f92:	f888 0000 	strb.w	r0, [r8]
		pbData[1] = 0;
    4f96:	f888 3001 	strb.w	r3, [r8, #1]
		*piLen = 2;
    4f9a:	603e      	str	r6, [r7, #0]
    4f9c:	e7d5      	b.n	4f4a <USBHandleStandardRequest+0xc2>
		break;
		
	case REQ_CLEAR_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
    4f9e:	8869      	ldrh	r1, [r5, #2]
    4fa0:	b941      	cbnz	r1, 4fb4 <USBHandleStandardRequest+0x12c>
			// clear HALT by unstalling
			USBHwEPStall(pSetup->wIndex, FALSE);
    4fa2:	7928      	ldrb	r0, [r5, #4]
    4fa4:	e003      	b.n	4fae <USBHandleStandardRequest+0x126>
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;
	
	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
    4fa6:	886b      	ldrh	r3, [r5, #2]
    4fa8:	b923      	cbnz	r3, 4fb4 <USBHandleStandardRequest+0x12c>
			// set HALT by stalling
			USBHwEPStall(pSetup->wIndex, TRUE);
    4faa:	7928      	ldrb	r0, [r5, #4]
    4fac:	2101      	movs	r1, #1
    4fae:	f7ff fdcb 	bl	4b48 <USBHwEPStall>
    4fb2:	e7ca      	b.n	4f4a <USBHandleStandardRequest+0xc2>
		break;
	
	case REQ_SET_INTERFACE:	// TODO use bNumInterfaces
		// there is only one interface (= 0)
		if (pSetup->wValue != 0) {
			return FALSE;
    4fb4:	2000      	movs	r0, #0
	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
	default: 						return FALSE;
	}
}
    4fb6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4fba:	bf00      	nop
    4fbc:	100007d8 	.word	0x100007d8

00004fc0 <memcpy>:
    4fc0:	4684      	mov	ip, r0
    4fc2:	ea41 0300 	orr.w	r3, r1, r0
    4fc6:	f013 0303 	ands.w	r3, r3, #3
    4fca:	d149      	bne.n	5060 <memcpy+0xa0>
    4fcc:	3a40      	subs	r2, #64	; 0x40
    4fce:	d323      	bcc.n	5018 <memcpy+0x58>
    4fd0:	680b      	ldr	r3, [r1, #0]
    4fd2:	6003      	str	r3, [r0, #0]
    4fd4:	684b      	ldr	r3, [r1, #4]
    4fd6:	6043      	str	r3, [r0, #4]
    4fd8:	688b      	ldr	r3, [r1, #8]
    4fda:	6083      	str	r3, [r0, #8]
    4fdc:	68cb      	ldr	r3, [r1, #12]
    4fde:	60c3      	str	r3, [r0, #12]
    4fe0:	690b      	ldr	r3, [r1, #16]
    4fe2:	6103      	str	r3, [r0, #16]
    4fe4:	694b      	ldr	r3, [r1, #20]
    4fe6:	6143      	str	r3, [r0, #20]
    4fe8:	698b      	ldr	r3, [r1, #24]
    4fea:	6183      	str	r3, [r0, #24]
    4fec:	69cb      	ldr	r3, [r1, #28]
    4fee:	61c3      	str	r3, [r0, #28]
    4ff0:	6a0b      	ldr	r3, [r1, #32]
    4ff2:	6203      	str	r3, [r0, #32]
    4ff4:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    4ff6:	6243      	str	r3, [r0, #36]	; 0x24
    4ff8:	6a8b      	ldr	r3, [r1, #40]	; 0x28
    4ffa:	6283      	str	r3, [r0, #40]	; 0x28
    4ffc:	6acb      	ldr	r3, [r1, #44]	; 0x2c
    4ffe:	62c3      	str	r3, [r0, #44]	; 0x2c
    5000:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    5002:	6303      	str	r3, [r0, #48]	; 0x30
    5004:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    5006:	6343      	str	r3, [r0, #52]	; 0x34
    5008:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    500a:	6383      	str	r3, [r0, #56]	; 0x38
    500c:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
    500e:	63c3      	str	r3, [r0, #60]	; 0x3c
    5010:	3040      	adds	r0, #64	; 0x40
    5012:	3140      	adds	r1, #64	; 0x40
    5014:	3a40      	subs	r2, #64	; 0x40
    5016:	d2db      	bcs.n	4fd0 <memcpy+0x10>
    5018:	3230      	adds	r2, #48	; 0x30
    501a:	d30b      	bcc.n	5034 <memcpy+0x74>
    501c:	680b      	ldr	r3, [r1, #0]
    501e:	6003      	str	r3, [r0, #0]
    5020:	684b      	ldr	r3, [r1, #4]
    5022:	6043      	str	r3, [r0, #4]
    5024:	688b      	ldr	r3, [r1, #8]
    5026:	6083      	str	r3, [r0, #8]
    5028:	68cb      	ldr	r3, [r1, #12]
    502a:	60c3      	str	r3, [r0, #12]
    502c:	3010      	adds	r0, #16
    502e:	3110      	adds	r1, #16
    5030:	3a10      	subs	r2, #16
    5032:	d2f3      	bcs.n	501c <memcpy+0x5c>
    5034:	320c      	adds	r2, #12
    5036:	d305      	bcc.n	5044 <memcpy+0x84>
    5038:	f851 3b04 	ldr.w	r3, [r1], #4
    503c:	f840 3b04 	str.w	r3, [r0], #4
    5040:	3a04      	subs	r2, #4
    5042:	d2f9      	bcs.n	5038 <memcpy+0x78>
    5044:	3204      	adds	r2, #4
    5046:	d008      	beq.n	505a <memcpy+0x9a>
    5048:	07d2      	lsls	r2, r2, #31
    504a:	bf1c      	itt	ne
    504c:	f811 3b01 	ldrbne.w	r3, [r1], #1
    5050:	f800 3b01 	strbne.w	r3, [r0], #1
    5054:	d301      	bcc.n	505a <memcpy+0x9a>
    5056:	880b      	ldrh	r3, [r1, #0]
    5058:	8003      	strh	r3, [r0, #0]
    505a:	4660      	mov	r0, ip
    505c:	4770      	bx	lr
    505e:	bf00      	nop
    5060:	2a08      	cmp	r2, #8
    5062:	d313      	bcc.n	508c <memcpy+0xcc>
    5064:	078b      	lsls	r3, r1, #30
    5066:	d0b1      	beq.n	4fcc <memcpy+0xc>
    5068:	f010 0303 	ands.w	r3, r0, #3
    506c:	d0ae      	beq.n	4fcc <memcpy+0xc>
    506e:	f1c3 0304 	rsb	r3, r3, #4
    5072:	1ad2      	subs	r2, r2, r3
    5074:	07db      	lsls	r3, r3, #31
    5076:	bf1c      	itt	ne
    5078:	f811 3b01 	ldrbne.w	r3, [r1], #1
    507c:	f800 3b01 	strbne.w	r3, [r0], #1
    5080:	d3a4      	bcc.n	4fcc <memcpy+0xc>
    5082:	f831 3b02 	ldrh.w	r3, [r1], #2
    5086:	f820 3b02 	strh.w	r3, [r0], #2
    508a:	e79f      	b.n	4fcc <memcpy+0xc>
    508c:	3a04      	subs	r2, #4
    508e:	d3d9      	bcc.n	5044 <memcpy+0x84>
    5090:	3a01      	subs	r2, #1
    5092:	f811 3b01 	ldrb.w	r3, [r1], #1
    5096:	f800 3b01 	strb.w	r3, [r0], #1
    509a:	d2f9      	bcs.n	5090 <memcpy+0xd0>
    509c:	780b      	ldrb	r3, [r1, #0]
    509e:	7003      	strb	r3, [r0, #0]
    50a0:	784b      	ldrb	r3, [r1, #1]
    50a2:	7043      	strb	r3, [r0, #1]
    50a4:	788b      	ldrb	r3, [r1, #2]
    50a6:	7083      	strb	r3, [r0, #2]
    50a8:	4660      	mov	r0, ip
    50aa:	4770      	bx	lr
    50ac:	00000043 	.word	0x00000043

000050b0 <_global_impure_ptr>:
    50b0:	10000020                                 ...

000050b4 <abExtendedOsFeatureDescriptor>:
    50b4:	00000028 00040100 00000001 00000000     (...............
    50c4:	49570100 4253554e 00000000 00000000     ..WINUSB........
    50d4:	00000000 00000000                       ........

000050dc <_init>:
    50dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    50de:	bf00      	nop
    50e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
    50e2:	bc08      	pop	{r3}
    50e4:	469e      	mov	lr, r3
    50e6:	4770      	bx	lr

000050e8 <__init_array_start>:
    50e8:	00004179 	.word	0x00004179

000050ec <__frame_dummy_init_array_entry>:
    50ec:	000040f1                                .@..

000050f0 <_fini>:
    50f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    50f2:	bf00      	nop
    50f4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    50f6:	bc08      	pop	{r3}
    50f8:	469e      	mov	lr, r3
    50fa:	4770      	bx	lr

000050fc <__fini_array_start>:
    50fc:	000040cd 	.word	0x000040cd
