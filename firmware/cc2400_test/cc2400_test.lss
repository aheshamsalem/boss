
cc2400_test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004c8  00004000  00004000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .persistent   00000020  10000000  10000000  00010000  2**0
                  ALLOC
  2 .data         00000428  10000020  000044c8  00008020  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000024  10000448  000048f0  00008448  2**2
                  ALLOC
  4 .ARM.attributes 00000029  00000000  00000000  00008448  2**0
                  CONTENTS, READONLY
  5 .comment      00000070  00000000  00000000  00008471  2**0
                  CONTENTS, READONLY
  6 .debug_frame  00000490  00000000  00000000  000084e4  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000d2c  00000000  00000000  00008974  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000004b5  00000000  00000000  000096a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000168  00000000  00000000  00009b55  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000158  00000000  00000000  00009cbd  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000067c  00000000  00000000  00009e15  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000004d9  00000000  00000000  0000a491  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00000670  00000000  00000000  0000a96a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00004000 <_NVIC_Handler_Functions>:
    4000:	e0 3f 00 10 99 42 00 00 ed 42 00 00 ed 42 00 00     .?...B...B...B..
    4010:	ed 42 00 00 ed 42 00 00 ed 42 00 00 00 00 00 00     .B...B...B......
    4020:	00 00 00 00 00 00 00 00 00 00 00 00 ed 42 00 00     .............B..
    4030:	ed 42 00 00 00 00 00 00 ed 42 00 00 ed 42 00 00     .B.......B...B..
    4040:	ed 42 00 00 ed 42 00 00 ed 42 00 00 ed 42 00 00     .B...B...B...B..
    4050:	ed 42 00 00 ed 42 00 00 ed 42 00 00 ed 42 00 00     .B...B...B...B..
    4060:	ed 42 00 00 ed 42 00 00 ed 42 00 00 ed 42 00 00     .B...B...B...B..
    4070:	ed 42 00 00 ed 42 00 00 ed 42 00 00 ed 42 00 00     .B...B...B...B..
    4080:	ed 42 00 00 ed 42 00 00 ed 42 00 00 ed 42 00 00     .B...B...B...B..
    4090:	ed 42 00 00 ed 42 00 00 ed 42 00 00 ed 42 00 00     .B...B...B...B..
    40a0:	ed 42 00 00 ed 42 00 00 ed 42 00 00 ed 42 00 00     .B...B...B...B..
    40b0:	ed 42 00 00 ed 42 00 00 ed 42 00 00 ed 42 00 00     .B...B...B...B..
    40c0:	ed 42 00 00 ed 42 00 00 ed 42 00 00                 .B...B...B..

000040cc <__do_global_dtors_aux>:
    40cc:	b510      	push	{r4, lr}
    40ce:	4c05      	ldr	r4, [pc, #20]	; (40e4 <__do_global_dtors_aux+0x18>)
    40d0:	7823      	ldrb	r3, [r4, #0]
    40d2:	b933      	cbnz	r3, 40e2 <__do_global_dtors_aux+0x16>
    40d4:	4b04      	ldr	r3, [pc, #16]	; (40e8 <__do_global_dtors_aux+0x1c>)
    40d6:	b113      	cbz	r3, 40de <__do_global_dtors_aux+0x12>
    40d8:	4804      	ldr	r0, [pc, #16]	; (40ec <__do_global_dtors_aux+0x20>)
    40da:	f3af 8000 	nop.w
    40de:	2301      	movs	r3, #1
    40e0:	7023      	strb	r3, [r4, #0]
    40e2:	bd10      	pop	{r4, pc}
    40e4:	10000448 	.word	0x10000448
    40e8:	00000000 	.word	0x00000000
    40ec:	000044a4 	.word	0x000044a4

000040f0 <frame_dummy>:
    40f0:	4b08      	ldr	r3, [pc, #32]	; (4114 <frame_dummy+0x24>)
    40f2:	b510      	push	{r4, lr}
    40f4:	b11b      	cbz	r3, 40fe <frame_dummy+0xe>
    40f6:	4808      	ldr	r0, [pc, #32]	; (4118 <frame_dummy+0x28>)
    40f8:	4908      	ldr	r1, [pc, #32]	; (411c <frame_dummy+0x2c>)
    40fa:	f3af 8000 	nop.w
    40fe:	4808      	ldr	r0, [pc, #32]	; (4120 <frame_dummy+0x30>)
    4100:	6803      	ldr	r3, [r0, #0]
    4102:	b903      	cbnz	r3, 4106 <frame_dummy+0x16>
    4104:	bd10      	pop	{r4, pc}
    4106:	4b07      	ldr	r3, [pc, #28]	; (4124 <frame_dummy+0x34>)
    4108:	2b00      	cmp	r3, #0
    410a:	d0fb      	beq.n	4104 <frame_dummy+0x14>
    410c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    4110:	4718      	bx	r3
    4112:	bf00      	nop
    4114:	00000000 	.word	0x00000000
    4118:	000044a4 	.word	0x000044a4
    411c:	1000044c 	.word	0x1000044c
    4120:	10000448 	.word	0x10000448
    4124:	00000000 	.word	0x00000000

00004128 <__libc_init_array>:
    4128:	b570      	push	{r4, r5, r6, lr}
    412a:	4e0f      	ldr	r6, [pc, #60]	; (4168 <__libc_init_array+0x40>)
    412c:	4d0f      	ldr	r5, [pc, #60]	; (416c <__libc_init_array+0x44>)
    412e:	1b76      	subs	r6, r6, r5
    4130:	10b6      	asrs	r6, r6, #2
    4132:	bf18      	it	ne
    4134:	2400      	movne	r4, #0
    4136:	d005      	beq.n	4144 <__libc_init_array+0x1c>
    4138:	3401      	adds	r4, #1
    413a:	f855 3b04 	ldr.w	r3, [r5], #4
    413e:	4798      	blx	r3
    4140:	42a6      	cmp	r6, r4
    4142:	d1f9      	bne.n	4138 <__libc_init_array+0x10>
    4144:	4e0a      	ldr	r6, [pc, #40]	; (4170 <__libc_init_array+0x48>)
    4146:	4d0b      	ldr	r5, [pc, #44]	; (4174 <__libc_init_array+0x4c>)
    4148:	f000 f9ac 	bl	44a4 <_init>
    414c:	1b76      	subs	r6, r6, r5
    414e:	10b6      	asrs	r6, r6, #2
    4150:	bf18      	it	ne
    4152:	2400      	movne	r4, #0
    4154:	d006      	beq.n	4164 <__libc_init_array+0x3c>
    4156:	3401      	adds	r4, #1
    4158:	f855 3b04 	ldr.w	r3, [r5], #4
    415c:	4798      	blx	r3
    415e:	42a6      	cmp	r6, r4
    4160:	d1f9      	bne.n	4156 <__libc_init_array+0x2e>
    4162:	bd70      	pop	{r4, r5, r6, pc}
    4164:	bd70      	pop	{r4, r5, r6, pc}
    4166:	bf00      	nop
    4168:	000044b0 	.word	0x000044b0
    416c:	000044b0 	.word	0x000044b0
    4170:	000044b8 	.word	0x000044b8
    4174:	000044b0 	.word	0x000044b0

00004178 <register_fini>:
    4178:	4b02      	ldr	r3, [pc, #8]	; (4184 <register_fini+0xc>)
    417a:	b113      	cbz	r3, 4182 <register_fini+0xa>
    417c:	4802      	ldr	r0, [pc, #8]	; (4188 <register_fini+0x10>)
    417e:	f000 b805 	b.w	418c <atexit>
    4182:	4770      	bx	lr
    4184:	00000000 	.word	0x00000000
    4188:	00004199 	.word	0x00004199

0000418c <atexit>:
    418c:	4601      	mov	r1, r0
    418e:	2000      	movs	r0, #0
    4190:	4602      	mov	r2, r0
    4192:	4603      	mov	r3, r0
    4194:	f000 b816 	b.w	41c4 <__register_exitproc>

00004198 <__libc_fini_array>:
    4198:	b538      	push	{r3, r4, r5, lr}
    419a:	4b08      	ldr	r3, [pc, #32]	; (41bc <__libc_fini_array+0x24>)
    419c:	4d08      	ldr	r5, [pc, #32]	; (41c0 <__libc_fini_array+0x28>)
    419e:	1aed      	subs	r5, r5, r3
    41a0:	10ac      	asrs	r4, r5, #2
    41a2:	bf18      	it	ne
    41a4:	18ed      	addne	r5, r5, r3
    41a6:	d005      	beq.n	41b4 <__libc_fini_array+0x1c>
    41a8:	3c01      	subs	r4, #1
    41aa:	f855 3d04 	ldr.w	r3, [r5, #-4]!
    41ae:	4798      	blx	r3
    41b0:	2c00      	cmp	r4, #0
    41b2:	d1f9      	bne.n	41a8 <__libc_fini_array+0x10>
    41b4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    41b8:	f000 b97e 	b.w	44b8 <_fini>
    41bc:	000044c4 	.word	0x000044c4
    41c0:	000044c8 	.word	0x000044c8

000041c4 <__register_exitproc>:
    41c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    41c8:	4c25      	ldr	r4, [pc, #148]	; (4260 <__register_exitproc+0x9c>)
    41ca:	4606      	mov	r6, r0
    41cc:	6825      	ldr	r5, [r4, #0]
    41ce:	4688      	mov	r8, r1
    41d0:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    41d4:	4692      	mov	sl, r2
    41d6:	4699      	mov	r9, r3
    41d8:	b3c4      	cbz	r4, 424c <__register_exitproc+0x88>
    41da:	6860      	ldr	r0, [r4, #4]
    41dc:	281f      	cmp	r0, #31
    41de:	dc17      	bgt.n	4210 <__register_exitproc+0x4c>
    41e0:	1c41      	adds	r1, r0, #1
    41e2:	b176      	cbz	r6, 4202 <__register_exitproc+0x3e>
    41e4:	eb04 0380 	add.w	r3, r4, r0, lsl #2
    41e8:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
    41ec:	f8d4 5188 	ldr.w	r5, [r4, #392]	; 0x188
    41f0:	2201      	movs	r2, #1
    41f2:	4082      	lsls	r2, r0
    41f4:	4315      	orrs	r5, r2
    41f6:	2e02      	cmp	r6, #2
    41f8:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
    41fc:	f8c3 9108 	str.w	r9, [r3, #264]	; 0x108
    4200:	d01e      	beq.n	4240 <__register_exitproc+0x7c>
    4202:	1c83      	adds	r3, r0, #2
    4204:	6061      	str	r1, [r4, #4]
    4206:	2000      	movs	r0, #0
    4208:	f844 8023 	str.w	r8, [r4, r3, lsl #2]
    420c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4210:	4b14      	ldr	r3, [pc, #80]	; (4264 <__register_exitproc+0xa0>)
    4212:	b303      	cbz	r3, 4256 <__register_exitproc+0x92>
    4214:	f44f 70c8 	mov.w	r0, #400	; 0x190
    4218:	f3af 8000 	nop.w
    421c:	4604      	mov	r4, r0
    421e:	b1d0      	cbz	r0, 4256 <__register_exitproc+0x92>
    4220:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    4224:	2700      	movs	r7, #0
    4226:	e884 0088 	stmia.w	r4, {r3, r7}
    422a:	4638      	mov	r0, r7
    422c:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    4230:	2101      	movs	r1, #1
    4232:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    4236:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    423a:	2e00      	cmp	r6, #0
    423c:	d0e1      	beq.n	4202 <__register_exitproc+0x3e>
    423e:	e7d1      	b.n	41e4 <__register_exitproc+0x20>
    4240:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
    4244:	431a      	orrs	r2, r3
    4246:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    424a:	e7da      	b.n	4202 <__register_exitproc+0x3e>
    424c:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    4250:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    4254:	e7c1      	b.n	41da <__register_exitproc+0x16>
    4256:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    425a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    425e:	bf00      	nop
    4260:	000044a0 	.word	0x000044a0
    4264:	00000000 	.word	0x00000000

00004268 <main>:
 */

#include "ubertooth.h"

int main()
{
    4268:	b508      	push	{r3, lr}
	gpio_init();
	TXLED_SET;
    426a:	4c0a      	ldr	r4, [pc, #40]	; (4294 <main+0x2c>)

#include "ubertooth.h"

int main()
{
	gpio_init();
    426c:	f000 f880 	bl	4370 <gpio_init>
	TXLED_SET;
    4270:	f44f 7380 	mov.w	r3, #256	; 0x100
    4274:	6023      	str	r3, [r4, #0]

	cc2400_init();
    4276:	f000 f8d5 	bl	4424 <cc2400_init>
	RXLED_SET;
    427a:	2310      	movs	r3, #16
    427c:	6023      	str	r3, [r4, #0]

	cc2400_reset();
    427e:	f000 f8f6 	bl	446e <cc2400_reset>
	while (cc2400_get(AGCCTRL) != 0xf700);
    4282:	2004      	movs	r0, #4
    4284:	f000 f8ea 	bl	445c <cc2400_get>
    4288:	f5b0 4f77 	cmp.w	r0, #63232	; 0xf700
    428c:	d1f9      	bne.n	4282 <main+0x1a>
	USRLED_SET;
    428e:	2302      	movs	r3, #2
    4290:	6023      	str	r3, [r4, #0]

	while (1);
    4292:	e7fe      	b.n	4292 <main+0x2a>
    4294:	2009c038 	.word	0x2009c038

00004298 <Reset_Handler>:
extern void __libc_init_array(void);
extern int main(void);

/* Reset Handler */
void Reset_Handler(void)
{
    4298:	b508      	push	{r3, lr}
    429a:	4a0d      	ldr	r2, [pc, #52]	; (42d0 <Reset_Handler+0x38>)
    429c:	4b0d      	ldr	r3, [pc, #52]	; (42d4 <Reset_Handler+0x3c>)
	unsigned long *src, *dest;

	// Copy the data segment initializers from flash to SRAM
	src = &_etext;
	for(dest = &_data; dest < &_edata; )
    429e:	490e      	ldr	r1, [pc, #56]	; (42d8 <Reset_Handler+0x40>)
    42a0:	428b      	cmp	r3, r1
    42a2:	d204      	bcs.n	42ae <Reset_Handler+0x16>
	{
		*dest++ = *src++;
    42a4:	f852 1f04 	ldr.w	r1, [r2, #4]!
    42a8:	f843 1b04 	str.w	r1, [r3], #4
    42ac:	e7f7      	b.n	429e <Reset_Handler+0x6>
    42ae:	4b0b      	ldr	r3, [pc, #44]	; (42dc <Reset_Handler+0x44>)
	}

	// Initialize the .bss segment of memory to zeros
	src = &_bss;
	while (src < &_ebss)
    42b0:	4a0b      	ldr	r2, [pc, #44]	; (42e0 <Reset_Handler+0x48>)
    42b2:	4293      	cmp	r3, r2
    42b4:	d203      	bcs.n	42be <Reset_Handler+0x26>
	{
		*src++ = 0;
    42b6:	2200      	movs	r2, #0
    42b8:	f843 2b04 	str.w	r2, [r3], #4
    42bc:	e7f8      	b.n	42b0 <Reset_Handler+0x18>
	}

	__libc_init_array();
    42be:	f7ff ff33 	bl	4128 <__libc_init_array>

	// Set the vector table location.
	SCB_VTOR = (uint32_t)&_interrupt_vector_table;
    42c2:	4b08      	ldr	r3, [pc, #32]	; (42e4 <Reset_Handler+0x4c>)
    42c4:	4a08      	ldr	r2, [pc, #32]	; (42e8 <Reset_Handler+0x50>)
    42c6:	601a      	str	r2, [r3, #0]

	main();
    42c8:	f7ff ffce 	bl	4268 <main>

	// In case main() fails, have something to breakpoint
	while (1) {;}
    42cc:	e7fe      	b.n	42cc <Reset_Handler+0x34>
    42ce:	bf00      	nop
    42d0:	000044c4 	.word	0x000044c4
    42d4:	10000020 	.word	0x10000020
    42d8:	10000448 	.word	0x10000448
    42dc:	10000448 	.word	0x10000448
    42e0:	1000046c 	.word	0x1000046c
    42e4:	e000ed08 	.word	0xe000ed08
    42e8:	00004000 	.word	0x00004000

000042ec <ADC_IRQHandler>:
extern unsigned long _StackTop;

extern void Reset_Handler(void);

/* Default interrupt handler */
static void Default_Handler(void) { while(1) {;} }
    42ec:	e7fe      	b.n	42ec <ADC_IRQHandler>
    42ee:	0000      	movs	r0, r0

000042f0 <wait_us>:
	/* This is binary multiply by ~0.3999, i.e, multiply by
	   0.011011011b. The loop also contains 6 instructions at -Os, so
	   why this factor works is not at all related to the comment
	   above ;-) */
	wait_us_counter =
		(us>>2) + (us>>3) + (us>>6) + (us>>7) + (us>>10) + (us>>11);
    42f0:	0883      	lsrs	r3, r0, #2
    42f2:	eb03 03d0 	add.w	r3, r3, r0, lsr #3
    42f6:	eb03 1390 	add.w	r3, r3, r0, lsr #6
    42fa:	eb03 13d0 	add.w	r3, r3, r0, lsr #7
    42fe:	eb03 2390 	add.w	r3, r3, r0, lsr #10
    4302:	eb03 20d0 	add.w	r0, r3, r0, lsr #11
{
	/* This is binary multiply by ~0.3999, i.e, multiply by
	   0.011011011b. The loop also contains 6 instructions at -Os, so
	   why this factor works is not at all related to the comment
	   above ;-) */
	wait_us_counter =
    4306:	4b04      	ldr	r3, [pc, #16]	; (4318 <wait_us+0x28>)
    4308:	6058      	str	r0, [r3, #4]
		(us>>2) + (us>>3) + (us>>6) + (us>>7) + (us>>10) + (us>>11);
	while(--wait_us_counter);
    430a:	685a      	ldr	r2, [r3, #4]
    430c:	3a01      	subs	r2, #1
    430e:	605a      	str	r2, [r3, #4]
    4310:	2a00      	cmp	r2, #0
    4312:	d1fa      	bne.n	430a <wait_us+0x1a>
}
    4314:	4770      	bx	lr
    4316:	bf00      	nop
    4318:	10000464 	.word	0x10000464

0000431c <all_pins_off>:
}

void all_pins_off(void)
{
	/* configure all pins for GPIO */
	PINSEL0 = 0;
    431c:	4a10      	ldr	r2, [pc, #64]	; (4360 <all_pins_off+0x44>)
    431e:	2300      	movs	r3, #0
    4320:	6013      	str	r3, [r2, #0]
	PINSEL1 = 0;
    4322:	6053      	str	r3, [r2, #4]
	PINSEL2 = 0;
    4324:	6093      	str	r3, [r2, #8]
	PINSEL3 = 0;
    4326:	60d3      	str	r3, [r2, #12]
	PINSEL4 = 0;
    4328:	6113      	str	r3, [r2, #16]
	PINSEL7 = 0;
    432a:	61d3      	str	r3, [r2, #28]
	PINSEL9 = 0;
    432c:	6253      	str	r3, [r2, #36]	; 0x24
	PINSEL10 = 0;
    432e:	6293      	str	r3, [r2, #40]	; 0x28

	/* configure all pins as inputs */
	FIO0DIR = 0;
    4330:	4a0c      	ldr	r2, [pc, #48]	; (4364 <all_pins_off+0x48>)
    4332:	6013      	str	r3, [r2, #0]
	FIO1DIR = 0;
    4334:	6213      	str	r3, [r2, #32]
	FIO2DIR = 0;
    4336:	6413      	str	r3, [r2, #64]	; 0x40
	FIO3DIR = 0;
    4338:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4DIR = 0;
    433a:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

	/* pull-up on every pin */
	PINMODE0 = 0;
    433e:	4a0a      	ldr	r2, [pc, #40]	; (4368 <all_pins_off+0x4c>)
    4340:	6013      	str	r3, [r2, #0]
	PINMODE1 = 0;
    4342:	6053      	str	r3, [r2, #4]
	PINMODE2 = 0;
    4344:	6093      	str	r3, [r2, #8]
	PINMODE3 = 0;
    4346:	60d3      	str	r3, [r2, #12]
	PINMODE4 = 0;
    4348:	6113      	str	r3, [r2, #16]
	PINMODE7 = 0;
    434a:	61d3      	str	r3, [r2, #28]
	PINMODE9 = 0;
    434c:	6253      	str	r3, [r2, #36]	; 0x24

	/* set all outputs low */
	FIO0PIN = 0;
    434e:	4a07      	ldr	r2, [pc, #28]	; (436c <all_pins_off+0x50>)
    4350:	6013      	str	r3, [r2, #0]
	FIO1PIN = 0;
    4352:	6213      	str	r3, [r2, #32]
	FIO2PIN = 0;
    4354:	6413      	str	r3, [r2, #64]	; 0x40
	FIO3PIN = 0;
    4356:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4PIN = 0;
    4358:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
    435c:	4770      	bx	lr
    435e:	bf00      	nop
    4360:	4002c000 	.word	0x4002c000
    4364:	2009c000 	.word	0x2009c000
    4368:	4002c040 	.word	0x4002c040
    436c:	2009c014 	.word	0x2009c014

00004370 <gpio_init>:
/*
 * This should be called very early by every firmware in order to ensure safe
 * operating conditions for the CC2400.
 */
void gpio_init()
{
    4370:	b508      	push	{r3, lr}
	/* 
	 * Set all pins for GPIO.  This shouldn't be necessary after a reset, but
	 * we might get called at other times.
	 */
	all_pins_off();
    4372:	f7ff ffd3 	bl	431c <all_pins_off>
	FIO3DIR = 0;
	FIO4DIR = (PIN_RXLED | PIN_TXLED);
#endif
#ifdef UBERTOOTH_ONE
	FIO0DIR = 0;
	FIO1DIR = (PIN_USRLED | PIN_RXLED | PIN_TXLED | PIN_CC3V3 |
    4376:	f24c 7112 	movw	r1, #50962	; 0xc712
	FIO2DIR = PIN_SSEL0;
	FIO3DIR = 0;
	FIO4DIR = (PIN_RXLED | PIN_TXLED);
#endif
#ifdef UBERTOOTH_ONE
	FIO0DIR = 0;
    437a:	4a09      	ldr	r2, [pc, #36]	; (43a0 <gpio_init+0x30>)
    437c:	2300      	movs	r3, #0
    437e:	6013      	str	r3, [r2, #0]
	FIO1DIR = (PIN_USRLED | PIN_RXLED | PIN_TXLED | PIN_CC3V3 |
    4380:	6211      	str	r1, [r2, #32]
			PIN_RX | PIN_CC1V8 | PIN_BTGR);
	FIO2DIR = (PIN_CSN | PIN_SCLK | PIN_MOSI | PIN_PAEN | PIN_HGM);
    4382:	f240 11b1 	movw	r1, #433	; 0x1b1
    4386:	6411      	str	r1, [r2, #64]	; 0x40
	FIO3DIR = 0;
	FIO4DIR = (PIN_TX | PIN_SSEL1);
    4388:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
#ifdef UBERTOOTH_ONE
	FIO0DIR = 0;
	FIO1DIR = (PIN_USRLED | PIN_RXLED | PIN_TXLED | PIN_CC3V3 |
			PIN_RX | PIN_CC1V8 | PIN_BTGR);
	FIO2DIR = (PIN_CSN | PIN_SCLK | PIN_MOSI | PIN_PAEN | PIN_HGM);
	FIO3DIR = 0;
    438c:	6613      	str	r3, [r2, #96]	; 0x60
	FIO4DIR = (PIN_TX | PIN_SSEL1);
    438e:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80
	FIO3DIR = 0;
	FIO4DIR = 0;
#endif

	/* set all outputs low */
	FIO0PIN = 0;
    4392:	6153      	str	r3, [r2, #20]
	FIO1PIN = 0;
    4394:	6353      	str	r3, [r2, #52]	; 0x34
	FIO2PIN = 0;
    4396:	6553      	str	r3, [r2, #84]	; 0x54
	FIO3PIN = 0;
    4398:	6753      	str	r3, [r2, #116]	; 0x74
	FIO4PIN = 0;
    439a:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    439e:	bd08      	pop	{r3, pc}
    43a0:	2009c000 	.word	0x2009c000

000043a4 <atest_init>:
	 * ADC can optionally be configured for ATEST1 and ATEST2, but for now we
	 * set them as floating inputs.
	 */

	/* P0.25 is ATEST1, P0.26 is ATEST2 */
	PINSEL1 &= ~((0x3 << 20) | (0x3 << 18)); // set as GPIO
    43a4:	4a09      	ldr	r2, [pc, #36]	; (43cc <atest_init+0x28>)
    43a6:	6813      	ldr	r3, [r2, #0]
    43a8:	f423 1370 	bic.w	r3, r3, #3932160	; 0x3c0000
    43ac:	6013      	str	r3, [r2, #0]
	FIO0DIR &= ~(0x3 << 25); // set as input
    43ae:	4a08      	ldr	r2, [pc, #32]	; (43d0 <atest_init+0x2c>)
    43b0:	6813      	ldr	r3, [r2, #0]
    43b2:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
    43b6:	6013      	str	r3, [r2, #0]
	PINMODE1 |= (0x5 << 19); // no pull-up/pull-down
    43b8:	4b06      	ldr	r3, [pc, #24]	; (43d4 <atest_init+0x30>)
    43ba:	681a      	ldr	r2, [r3, #0]
    43bc:	f442 1220 	orr.w	r2, r2, #2621440	; 0x280000
    43c0:	601a      	str	r2, [r3, #0]
	PINMODE1 &= ~(0x5 << 18); // no pull-up/pull-down
    43c2:	681a      	ldr	r2, [r3, #0]
    43c4:	f422 12a0 	bic.w	r2, r2, #1310720	; 0x140000
    43c8:	601a      	str	r2, [r3, #0]
    43ca:	4770      	bx	lr
    43cc:	4002c004 	.word	0x4002c004
    43d0:	2009c000 	.word	0x2009c000
    43d4:	4002c044 	.word	0x4002c044

000043d8 <cc2400_spi>:
 * 2. We're saving the second SPI peripheral for an expansion port.
 * 3. The CC2400 needs CSN held low for the entire transaction which the
 *    LPC17xx SPI peripheral won't do without some workaround anyway.
 */
u32 cc2400_spi(u8 len, u32 data)
{
    43d8:	b530      	push	{r4, r5, lr}
	u32 msb = 1 << (len - 1);
    43da:	2501      	movs	r5, #1
    43dc:	1e43      	subs	r3, r0, #1
    43de:	409d      	lsls	r5, r3

	/* start transaction by dropping CSN */
	CSN_CLR;
    43e0:	4b0d      	ldr	r3, [pc, #52]	; (4418 <cc2400_spi+0x40>)
    43e2:	2220      	movs	r2, #32

	while (len--) {
    43e4:	3801      	subs	r0, #1
    43e6:	b2c0      	uxtb	r0, r0
    43e8:	28ff      	cmp	r0, #255	; 0xff

		SCLK_SET;
		if (MISO)
			data |= 1;

		SCLK_CLR;
    43ea:	601a      	str	r2, [r3, #0]
    43ec:	4c0b      	ldr	r4, [pc, #44]	; (441c <cc2400_spi+0x44>)
	u32 msb = 1 << (len - 1);

	/* start transaction by dropping CSN */
	CSN_CLR;

	while (len--) {
    43ee:	d00f      	beq.n	4410 <cc2400_spi+0x38>
		if (data & msb)
    43f0:	4229      	tst	r1, r5
    43f2:	f04f 0201 	mov.w	r2, #1
			MOSI_SET;
    43f6:	bf14      	ite	ne
    43f8:	6022      	strne	r2, [r4, #0]
		else
			MOSI_CLR;
    43fa:	601a      	streq	r2, [r3, #0]
		data <<= 1;

		SCLK_SET;
    43fc:	2210      	movs	r2, #16
    43fe:	6022      	str	r2, [r4, #0]
		if (MISO)
    4400:	4c07      	ldr	r4, [pc, #28]	; (4420 <cc2400_spi+0x48>)
	while (len--) {
		if (data & msb)
			MOSI_SET;
		else
			MOSI_CLR;
		data <<= 1;
    4402:	0049      	lsls	r1, r1, #1

		SCLK_SET;
		if (MISO)
    4404:	6824      	ldr	r4, [r4, #0]
    4406:	07a4      	lsls	r4, r4, #30
			data |= 1;
    4408:	bf48      	it	mi
    440a:	f041 0101 	orrmi.w	r1, r1, #1
    440e:	e7e9      	b.n	43e4 <cc2400_spi+0xc>

		SCLK_CLR;
	}

	/* end transaction by raising CSN */
	CSN_SET;
    4410:	2320      	movs	r3, #32
    4412:	6023      	str	r3, [r4, #0]

	return data;
}
    4414:	4608      	mov	r0, r1
    4416:	bd30      	pop	{r4, r5, pc}
    4418:	2009c05c 	.word	0x2009c05c
    441c:	2009c058 	.word	0x2009c058
    4420:	2009c054 	.word	0x2009c054

00004424 <cc2400_init>:
	PINMODE1 |= (0x5 << 19); // no pull-up/pull-down
	PINMODE1 &= ~(0x5 << 18); // no pull-up/pull-down
}

void cc2400_init()
{
    4424:	b510      	push	{r4, lr}
#else
	atest_init();
#endif

	/* activate 1V8 supply for CC2400 */
	CC1V8_SET;
    4426:	4c0a      	ldr	r4, [pc, #40]	; (4450 <cc2400_init+0x2c>)
	FIO1PIN = 0; /* assuming we have already asserted R8C_CTL low */
	FIO2PIN = 0;
	FIO3PIN = 0;
	FIO4PIN = 0;
#else
	atest_init();
    4428:	f7ff ffbc 	bl	43a4 <atest_init>
#endif

	/* activate 1V8 supply for CC2400 */
	CC1V8_SET;
    442c:	f44f 7300 	mov.w	r3, #512	; 0x200
    4430:	6023      	str	r3, [r4, #0]
	wait_us(50);
    4432:	2032      	movs	r0, #50	; 0x32
    4434:	f7ff ff5c 	bl	42f0 <wait_us>

	/* CSN (slave select) is active low */
	CSN_SET;
    4438:	4b06      	ldr	r3, [pc, #24]	; (4454 <cc2400_init+0x30>)
    443a:	2220      	movs	r2, #32
    443c:	601a      	str	r2, [r3, #0]

	/* activate 3V3 supply for CC2400 IO */
	CC3V3_SET;
    443e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    4442:	6023      	str	r3, [r4, #0]

/* write 16 bit value to a register */
void cc2400_set(u8 reg, u16 val)
{
	u32 out = (reg << 16) | val;
	cc2400_spi(24, out);
    4444:	2018      	movs	r0, #24
    4446:	4904      	ldr	r1, [pc, #16]	; (4458 <cc2400_init+0x34>)
	/* activate 3V3 supply for CC2400 IO */
	CC3V3_SET;

	/* initialise various cc2400 settings - see datasheet pg63 */
	cc2400_set(MANAND,  0x7fff);
}
    4448:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

/* write 16 bit value to a register */
void cc2400_set(u8 reg, u16 val)
{
	u32 out = (reg << 16) | val;
	cc2400_spi(24, out);
    444c:	f7ff bfc4 	b.w	43d8 <cc2400_spi>
    4450:	2009c038 	.word	0x2009c038
    4454:	2009c058 	.word	0x2009c058
    4458:	000d7fff 	.word	0x000d7fff

0000445c <cc2400_get>:
	return data;
}

/* read 16 bit value from a register */
u16 cc2400_get(u8 reg)
{
    445c:	b508      	push	{r3, lr}
	u32 in;

	u32 out = (reg | 0x80) << 16;
    445e:	f040 0180 	orr.w	r1, r0, #128	; 0x80
	in = cc2400_spi(24, out);
    4462:	0409      	lsls	r1, r1, #16
    4464:	2018      	movs	r0, #24
    4466:	f7ff ffb7 	bl	43d8 <cc2400_spi>
	return in & 0xFFFF;
}
    446a:	b280      	uxth	r0, r0
    446c:	bd08      	pop	{r3, pc}

0000446e <cc2400_reset>:
/*
 * Warning: This should only be called when running on the internal oscillator.
 * Otherwise use clock_start().
 */
void cc2400_reset()
{
    446e:	b508      	push	{r3, lr}

/* write 16 bit value to a register */
void cc2400_set(u8 reg, u16 val)
{
	u32 out = (reg << 16) | val;
	cc2400_spi(24, out);
    4470:	2018      	movs	r0, #24
    4472:	2100      	movs	r1, #0
    4474:	f7ff ffb0 	bl	43d8 <cc2400_spi>
 * Otherwise use clock_start().
 */
void cc2400_reset()
{
	cc2400_set(MAIN, 0x0000);
	while (cc2400_get(MAIN) != 0x0000);
    4478:	2000      	movs	r0, #0
    447a:	f7ff ffef 	bl	445c <cc2400_get>
    447e:	2800      	cmp	r0, #0
    4480:	d1fa      	bne.n	4478 <cc2400_reset+0xa>

/* write 16 bit value to a register */
void cc2400_set(u8 reg, u16 val)
{
	u32 out = (reg << 16) | val;
	cc2400_spi(24, out);
    4482:	2018      	movs	r0, #24
    4484:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    4488:	f7ff ffa6 	bl	43d8 <cc2400_spi>
void cc2400_reset()
{
	cc2400_set(MAIN, 0x0000);
	while (cc2400_get(MAIN) != 0x0000);
	cc2400_set(MAIN, 0x8000);
	while (cc2400_get(MAIN) != 0x8000);
    448c:	2000      	movs	r0, #0
    448e:	f7ff ffe5 	bl	445c <cc2400_get>
    4492:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
    4496:	d1f9      	bne.n	448c <cc2400_reset+0x1e>
}
    4498:	bd08      	pop	{r3, pc}
    449a:	0000      	movs	r0, r0
    449c:	00000043 	.word	0x00000043

000044a0 <_global_impure_ptr>:
    44a0:	10000020                                 ...

000044a4 <_init>:
    44a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    44a6:	bf00      	nop
    44a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    44aa:	bc08      	pop	{r3}
    44ac:	469e      	mov	lr, r3
    44ae:	4770      	bx	lr

000044b0 <__init_array_start>:
    44b0:	00004179 	.word	0x00004179

000044b4 <__frame_dummy_init_array_entry>:
    44b4:	000040f1                                .@..

000044b8 <_fini>:
    44b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    44ba:	bf00      	nop
    44bc:	bcf8      	pop	{r3, r4, r5, r6, r7}
    44be:	bc08      	pop	{r3}
    44c0:	469e      	mov	lr, r3
    44c2:	4770      	bx	lr

000044c4 <__fini_array_start>:
    44c4:	000040cd 	.word	0x000040cd
